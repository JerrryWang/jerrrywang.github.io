<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>ORM之多表实例 | JerryWang</title><meta name="keywords" content="Django"><meta name="author" content="JerryWang"><meta name="copyright" content="JerryWang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="建立关系 显然，关系型数据库的强大之处就在于将表相互关联，Django提供了定义三种最常见的数据库关系类型的方法：  一对一: 一个人对应一个身份证号码，数据字段设置 unique。 一对多: 一个家庭有多个人，一般通过外键来实现。 多对多: 一个学生有多门课程，一个课程有很多学生，一般通过第三个表来实现关联。   表关系之多对一 ForeignKey1、多对一关系 要定义一个多对一关系，需要使用"><meta property="og:type" content="article"><meta property="og:title" content="ORM之多表实例"><meta property="og:url" content="https://jerrrywang.github.io/2021/11/12/Python/Django/Django%E4%B9%8B%E6%97%85/7.ORM%E4%B9%8B%E5%A4%9A%E8%A1%A8%E5%AE%9E%E4%BE%8B/index.html"><meta property="og:site_name" content="JerryWang"><meta property="og:description" content="建立关系 显然，关系型数据库的强大之处就在于将表相互关联，Django提供了定义三种最常见的数据库关系类型的方法：  一对一: 一个人对应一个身份证号码，数据字段设置 unique。 一对多: 一个家庭有多个人，一般通过外键来实现。 多对多: 一个学生有多门课程，一个课程有很多学生，一般通过第三个表来实现关联。   表关系之多对一 ForeignKey1、多对一关系 要定义一个多对一关系，需要使用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerrrywang.github.io/2018/10/11/photo/ming_9.jpg"><meta property="article:published_time" content="2021-11-12T07:18:58.000Z"><meta property="article:modified_time" content="2022-12-02T06:46:08.000Z"><meta property="article:author" content="JerryWang"><meta property="article:tag" content="Django"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://jerrrywang.github.io/2018/10/11/photo/ming_9.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jerrrywang.github.io/2021/11/12/Python/Django/Django%E4%B9%8B%E6%97%85/7.ORM%E4%B9%8B%E5%A4%9A%E8%A1%A8%E5%AE%9E%E4%BE%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://jerrrywang.github.io/api/shubiao/Cyan.ttf" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"NL6QRV8F8M",apiKey:"0b99ef5723aa77799f47331a0e3bc4ff",indexName:"my-blog",hits:{per_page:6},languages:{input_placeholder:"搜索文章",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,noticeOutdate:{limitDay:30,position:"top",messagePrev:"本文上次更新于",messageNext:"天前，文章内容可能已经过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!0},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: JerryWang",link:"链接: ",source:"来源: JerryWang",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"ORM之多表实例",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-12-02 14:46:08"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script src="/js/welcome.js"></script><script src="/js/sweetalert.js"></script><script src="/api/shubiao/sakuraDrops.js"></script><link rel="stylesheet" href="/css/sweetalert.css"><style>#toggle-sidebar{left:100px}</style><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://jerrrywang.github.io/api/npm/hexo-electric-clock-plus/clock.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">150</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">89</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-coffee"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-bicycle"></i> <span>相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-heartbeat"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-motorcycle"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i> <span>电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>书籍</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://jerrrywang.github.io/2018/10/11/photo/ming_9.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JerryWang</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-coffee"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-bicycle"></i> <span>相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-heartbeat"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-motorcycle"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i> <span>电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>书籍</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ORM之多表实例</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-12T07:18:58.000Z" title="发表于 2021-11-12 15:18:58">2021-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-02T06:46:08.000Z" title="更新于 2022-12-02 14:46:08">2022-12-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Django/">Django</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Django/Django%E4%B9%8B%E6%97%85/">Django之旅</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="ORM之多表实例"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h1><p>显然，关系型数据库的强大之处就在于将表相互关联，Django提供了定义三种最常见的数据库关系类型的方法：</p><ul><li><strong>一对一</strong>: 一个人对应一个身份证号码，数据字段设置 unique。</li><li><strong>一对多</strong>: 一个家庭有多个人，一般通过外键来实现。</li><li><strong>多对多</strong>: 一个学生有多门课程，一个课程有很多学生，一般通过第三个表来实现关联。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2020/05/orm11.png" alt="orm11"></p><h2 id="表关系之多对一-ForeignKey"><a href="#表关系之多对一-ForeignKey" class="headerlink" title="表关系之多对一 ForeignKey"></a>表关系之多对一 ForeignKey</h2><h3 id="1、多对一关系"><a href="#1、多对一关系" class="headerlink" title="1、多对一关系"></a><strong>1、多对一关系</strong></h3><p>要定义一个多对一关系，需要使用django.db.models.ForeignKey。您可以像使用任何其他字段类型一样去使用它：将其作为模型的类属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## ForeignKey需要两个位置参数：</span></span><br><span class="line">    <span class="number">1</span>、所关联的模型类</span><br><span class="line">    <span class="number">2</span>、on_delete选项</span><br><span class="line"><span class="comment">## foreignkey相关的参数</span></span><br><span class="line">to,  <span class="comment"># 要进行关联的表名</span></span><br><span class="line">to_field = <span class="literal">None</span>,  <span class="comment"># 要关联的表中的字段名称</span></span><br><span class="line"></span><br><span class="line">on_delete = <span class="literal">None</span>,  <span class="comment"># 当删除关联表中的数据时，当前表与其关联的行的行为</span></span><br><span class="line">  - models.CASCADE，删除关联数据，与之关联也删除</span><br><span class="line">  - models.DO_NOTHING，删除关联数据，引发错误IntegrityError</span><br><span class="line">  - models.PROTECT，删除关联数据，引发错误ProtectedError</span><br><span class="line">  - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）</span><br><span class="line">  - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）</span><br><span class="line">  - models.SET，删除关联数据，</span><br><span class="line">    a.与之关联的值设置为指定值，设置：models.SET(值)</span><br><span class="line">    b.与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)</span><br><span class="line">    </span><br><span class="line">例：</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>(models.Model):</span><br><span class="line">    user = models.ForeignKey(</span><br><span class="line">        to=<span class="string">&quot;User&quot;</span>,</span><br><span class="line">        to_field=<span class="string">&quot;id&quot;</span></span><br><span class="line">        on_delete = models.SET(func),)</span><br></pre></td></tr></table></figure><p>例如： 制造商Manufacturer模型 汽车Car模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manufacturer</span>(models.Model):</span><br><span class="line">    <span class="comment">## ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(models.Model):</span><br><span class="line">    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment">## ...</span></span><br></pre></td></tr></table></figure><p>建议（但不是必需的）ForeignKey字段的名称是模型的名称、小写（如上述manufacturer），这么做是为了在后期进行查询操作时方便自己识别。当然，你想叫什么就叫什么。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(models.Model):</span><br><span class="line">    company_that_makes_it = models.ForeignKey(</span><br><span class="line">        Manufacturer,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">## ...</span></span><br></pre></td></tr></table></figure><h3 id="2、惰性关系"><a href="#2、惰性关系" class="headerlink" title="2、惰性关系"></a><strong>2、惰性关系</strong></h3><p>上述关联关系的建立，由于ForeignKey的第一个位置参数是模型类，所以模型Car必须在Manufacturer之后，若想排除先后顺序带来的困扰，即需要创建与尚未定义的模型类的关系，可以将ForeignKey的第一个参数换成字符串形式，如下所示，这种定义关系的形式，称之为惰性关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(models.Model):</span><br><span class="line">    manufacturer = models.ForeignKey(<span class="string">&#x27;Manufacturer&#x27;</span>, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment">## ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manufacturer</span>(models.Model):</span><br><span class="line">    <span class="comment">## ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="3、自关联"><a href="#3、自关联" class="headerlink" title="3、自关联"></a><strong>3、自关联</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    <span class="comment">## 评论者</span></span><br><span class="line">    user=models.ForeignKey(to=<span class="string">&#x27;User&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment">## 评论的文章</span></span><br><span class="line">    article=models.ForeignKey(to=<span class="string">&#x27;Article&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment">## 评论的内容</span></span><br><span class="line">    content=models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    <span class="comment">## 评论时间</span></span><br><span class="line">    create_time=models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">## 自关联</span></span><br><span class="line">    parent_comment=models.ForeignKey(to=<span class="string">&#x27;self&#x27;</span>,on_delete=models.CASCADE,null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a><strong>4、其他</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数据库表示：</span><br><span class="line">    默认情况下，在数据库层面，django会在ForeignKey的字段后加后缀“_<span class="built_in">id</span>”，即上述模型字段manufacturer对应的数据库表字段为manufacturer_id（我们可以用过db_column选项来进行自定义）</span><br><span class="line"></span><br><span class="line">    但是，我们在操作模型时只需要基于模型字段名字即可，只有在编写原生sql时才需要考虑数据库里的字段。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db_index</span><br><span class="line">    django会自动为ForeignKey字段创建索引，可以指定db_index=<span class="literal">False</span>来禁用此功能。</span><br><span class="line"></span><br><span class="line">    如果我们创建外键的目的是为了一致性而不是链接，或者你需要使用自定义的部分或多列索引，那么需要将db_index设置为<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">ForeignKey的其他详细参数：https://docs.djangoproject.com/zh-hans/<span class="number">3.2</span>/ref/models/fields/<span class="comment">#arguments</span></span><br></pre></td></tr></table></figure><h2 id="表关系之多对多-ManyToManyField"><a href="#表关系之多对多-ManyToManyField" class="headerlink" title="表关系之多对多 ManyToManyField"></a>表关系之多对多 ManyToManyField</h2><h3 id="1、多对多关系"><a href="#1、多对多关系" class="headerlink" title="1、多对多关系"></a>1、多对多关系</h3><p>定义多对多关系，需要使用ManyToManyField, 您可以像使用任何其他字段类型一样去使用它：将其作为模型的类属性</p><p>它的工作原理与 <a target="_blank" rel="noopener" href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.ForeignKey"><code>ForeignKey</code></a> 完全相同，包括 <a target="_blank" rel="noopener" href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#recursive-relationships">递归</a> 和 <a target="_blank" rel="noopener" href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#lazy-relationships">惰性</a> 关系。</p><p>可以通过字段的 <code>RelatedManager</code> 来添加、删除或创建相关对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ManyToManyField、需要一个位置参数：</span></span><br><span class="line"><span class="number">1</span>、to：所关联的模型类 </span><br><span class="line"><span class="number">2</span>、to_field: 设置要关联表的字段</span><br><span class="line"><span class="number">3</span>、related_name: 同ForeignKey，此处暂且忽略，会在后续章节专门介绍</span><br><span class="line"><span class="number">4</span>、related_query_name: 同ForeignKey，此处暂且忽略，会在后续章节专门介绍</span><br><span class="line"><span class="number">5</span>、db_constraint：是否在数据库中创建外键约束，默认为<span class="literal">True</span>。</span><br><span class="line"><span class="number">6</span>、db_table: 默认创建第三张表时，数据库中该表的名称。</span><br><span class="line"><span class="number">7</span>、symmetrical：默认为<span class="literal">True</span>，控制迁移框架的反应</span><br><span class="line"><span class="number">8</span>、through: 详见本节<span class="string">&quot;3、多对多额外的字段：中间模型&quot;</span></span><br><span class="line"><span class="number">9</span>、through_fileds：详见本节<span class="string">&quot;3、多对多额外的字段：中间模型&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># MannyToMany的其他详细参数：</span></span><br><span class="line">https://docs.djangoproject.com/zh-hans/<span class="number">3.2</span>/ref/models/fields/<span class="comment">#manytomany-arguments</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Topping</span>(models.Model): <span class="comment">## 馅料</span></span><br><span class="line">    <span class="comment">## ...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span>(models.Model): <span class="comment">## 披萨</span></span><br><span class="line">    <span class="comment">## ...</span></span><br><span class="line">    toppings = models.ManyToManyField(Topping)</span><br><span class="line"><span class="comment"># 数据库表示：</span></span><br><span class="line"> 在幕后，Django创建一个中间连接表来表示多对多关系。默认情况下，此表名是：包含该字段的模型的表名_多对多字段的名称。可以使用db_table选项手动设置连接表的名称。</span><br></pre></td></tr></table></figure><p>建议（但不是必须）ManyToMany的字段名称（上例中的toppings）是一个关联的模型类名字的复数形式，用于描述相关模型对象集。</p><p>针对ManyToMany字段，只要不是同时放入两个模型中，在哪个模型中创建并不重要，但是通常情况下我们需要考虑逻辑上的通顺已经后期的使用方便，字段与类是一个从属关系，toppings字段在类Pizza里，我们可以说Pizza拥有toppings，翻译一下就是披萨有馅料，显而易见这比在Topping类里放入MannyToMany字段，逻辑上更通顺，从而使得后期的使用更为方便</p><h3 id="2、惰性关系与自关联"><a href="#2、惰性关系与自关联" class="headerlink" title="2、惰性关系与自关联"></a>2、惰性关系与自关联</h3><p>​ 同ForeignKey一样</p><h3 id="3、多对多额外的字段：中间模型"><a href="#3、多对多额外的字段：中间模型" class="headerlink" title="3、多对多额外的字段：中间模型"></a>3、多对多额外的字段：中间模型</h3><p>使用标准的ManyToManyField创建多对多关系时，会自动生成第三张关系表，而关系表中只存放了最基本的数据，即两个模型的关联关系，大多数情况下这是没问题的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    books = models.ManyToManyField(to=<span class="string">&quot;Book&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 会自动生成第三张表，用来存放基本的关联关系</span></span><br><span class="line">create table book(<span class="built_in">id</span> <span class="built_in">int</span> primary key);</span><br><span class="line">create table author(<span class="built_in">id</span> <span class="built_in">int</span> primary key);</span><br><span class="line"></span><br><span class="line">create table app01_author_books(</span><br><span class="line">    <span class="built_in">id</span> <span class="built_in">int</span> primary key auto_increment,</span><br><span class="line">    author_id <span class="built_in">int</span>,</span><br><span class="line">    book_id <span class="built_in">int</span>,</span><br><span class="line">    foreign key(author_id) references Author(<span class="built_in">id</span>) on delete cascade,</span><br><span class="line">    foreign key(book_id) references Book(<span class="built_in">id</span>) on delete cascade,</span><br><span class="line">    unique(author_id,book_id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但如果我们需要在两个模型的多对多关系上添加额外的数据（比如有这样一个应用，它记录音乐家Person所属的音乐小组Group。我们想在多对多关系的基础上，知道更多成员关系的细节，比如成员是何时加入小组的,加入的理由是什么），<br>就需要我们自定义第三张关系表了，你可能会想到这么做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Membership</span>(models.Model):</span><br><span class="line">    person = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br><span class="line">    group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br><span class="line">    date_joined = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    invite_reason = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        <span class="comment">## 指定本模型中的两个字段person与group联合唯一</span></span><br><span class="line">        unique_together = (<span class="string">&quot;person&quot;</span>, <span class="string">&quot;group&quot;</span>)</span><br></pre></td></tr></table></figure><p>此时第三张表便是一张完全独立的表，这本身是没有问题的，但Person与Group与其关系表Membership<br>完全独立开意味着我们将无法使用django提供的关联查询功能，为此，django提供了一种改进方案:”使用through参数指定中间模型”，如下<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>)</span><br><span class="line">    <span class="comment">## through=&#x27;Membership&#x27;,指定中间模型为Membership</span></span><br><span class="line">    <span class="comment">## through_fields=(&#x27;person&#x27;,&#x27;group&#x27;),元组内第一个字段代表定义ManyToManyFiled的那个模型（此处为Group）对应的外键名称（此处为&#x27;group&#x27;），而元组的第二个字段代表目标模型（此处为Person）对应的外键名称（此处为&#x27;person&#x27;），切记顺序不可乱</span></span><br><span class="line">    members = models.ManyToManyField(Person, through=<span class="string">&#x27;Membership&#x27;</span>,through_fields=(<span class="string">&#x27;group&#x27;</span>,<span class="string">&#x27;person&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Membership</span>(models.Model): <span class="comment">## 称之为：中间模型</span></span><br><span class="line">    person = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br><span class="line">    group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br><span class="line">    date_joined = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    invite_reason = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样Group便可以通过字段members进行正向查询，Person便可以通过模型名group进行反向</span><br><span class="line">查询了</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1=Person(name=<span class="string">&#x27;牛逼鼓手小allen&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2=Person(name=<span class="string">&#x27;骚浪吉他手刘二蛋&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1=Group(name=<span class="string">&quot;狂拽炫酷屌炸天乐队&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2=Group(name=<span class="string">&quot;疯狂的唢呐乐队&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当我们使用第三种方式创建多对多关联关系时，就无法使用set、add、remove、clear方法来管理多对多的关系了，需要通过第三张表的model来管理多对多关系。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Membership.objects.create(person=p1,group=g1,invite_reason=<span class="string">&#x27;需要一名牛逼的鼓手&#x27;</span>)</span><br><span class="line">&lt;Membership: Membership <span class="built_in">object</span> (<span class="number">1</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Membership.objects.create(person=p2,group=g1,invite_reason=<span class="string">&#x27;需要一名骚浪吉他手&#x27;</span>)</span><br><span class="line">&lt;Membership: Membership <span class="built_in">object</span> (<span class="number">2</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Membership.objects.create(person=p2,group=g2,invite_reason=<span class="string">&#x27;需要一名骚浪吉他手&#x27;</span>)</span><br><span class="line">&lt;Membership: Membership <span class="built_in">object</span> (<span class="number">2</span>)&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1.members.<span class="built_in">all</span>()</span><br><span class="line">&lt;QuerySet [&lt;Person: 牛逼鼓手小allen&gt;, &lt;Person: 骚浪吉他手刘二蛋&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2.members.<span class="built_in">all</span>()</span><br><span class="line">&lt;QuerySet [&lt;Person: 骚浪吉他手刘二蛋&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.group_set.<span class="built_in">all</span>()</span><br><span class="line">&lt;QuerySet [&lt;Group: 狂拽炫酷屌炸天乐队&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2.group_set.<span class="built_in">all</span>()</span><br><span class="line">&lt;QuerySet [&lt;Group: 狂拽炫酷屌炸天乐队&gt;, &lt;Group: 疯狂的唢呐乐队&gt;]&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#clear()方法却是可用的。它可以清空某个实例所有的多对多关系：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1.members.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.group_set.<span class="built_in">all</span>()</span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2.group_set.<span class="built_in">all</span>()</span><br><span class="line">&lt;QuerySet [&lt;Group: 疯狂的唢呐乐队&gt;]&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="4、自关联"><a href="#4、自关联" class="headerlink" title="4、自关联"></a>4、自关联</h3><p>自己跟自己关联，默认是数据是对称的<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span>=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name=models.CharField(max_length=<span class="number">30</span>,null=<span class="literal">True</span>)</span><br><span class="line">    friends=models.ManyToManyField(<span class="string">&#x27;self&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj1=Person(name=<span class="string">&#x27;allen&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj2=Person(name=<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj2.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj1.friends.add(obj2)</span><br><span class="line">朋友关系表里会对称着，有两条记录</span><br><span class="line"></span><br><span class="line">数据库表里app01_person_friends</span><br><span class="line"><span class="built_in">id</span>       from_person_id          to_person_id</span><br><span class="line"><span class="number">1</span>                <span class="number">1</span>                    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>                <span class="number">2</span>                    <span class="number">1</span></span><br><span class="line"></span><br><span class="line">可以指定参数symmetrical=<span class="literal">False</span>，来关闭对称</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span>=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name=models.CharField(max_length=<span class="number">30</span>,null=<span class="literal">True</span>)</span><br><span class="line">    friends=models.ManyToManyField(<span class="string">&#x27;self&#x27;</span>,symmetrical=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果是自关联， 并且定制了中间模型，那么必须设置symmetrical=<span class="literal">False</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span>=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name=models.CharField(max_length=<span class="number">30</span>,null=<span class="literal">True</span>)</span><br><span class="line">    friends=models.ManyToManyField(<span class="string">&#x27;self&#x27;</span>,through=<span class="string">&#x27;PersonShip&#x27;</span>,symmetrical=<span class="literal">False</span>,through_fields=(<span class="string">&#x27;t_friend&#x27;</span>,<span class="string">&#x27;f_friend&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonShip</span>(models.Model):</span><br><span class="line">    create_time=models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    f_friend=models.ForeignKey(<span class="string">&#x27;Person&#x27;</span>,on_delete=models.CASCADE,)</span><br><span class="line">    t_friend=models.ForeignKey(<span class="string">&#x27;Person&#x27;</span>,on_delete=models.CASCADE,related_name=<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h2 id="表关系之一对一-OneToOneField"><a href="#表关系之一对一-OneToOneField" class="headerlink" title="表关系之一对一 OneToOneField"></a>表关系之一对一 OneToOneField</h2><h3 id="1、一对一关系"><a href="#1、一对一关系" class="headerlink" title="1、一对一关系"></a>1、一对一关系</h3><p>定义一对一关系，需要使用OneToOneField.、 您可以像使用任何其他字段类型一样去使用它：将其作为模型的类属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	# OneToOneField参数</span><br><span class="line">1、to：所关联的模型类</span><br><span class="line"> </span><br><span class="line">2、to_field: 设置要关联表的字段</span><br><span class="line"> </span><br><span class="line">3、on_delete：同ForeignKey</span><br></pre></td></tr></table></figure><p>示例</p><pre><code>在示例如中强调：OneToOneField就是在ForeignKey的基础上设置一个unique=True,只不过反向查询出的结果就一个对象，因为本质与ForeignKey类似，所以注意on_delete也是要加的

因为一对一满足“是”的关系，所以事实上，为了处理这个问题，你通常会使用继承，其中就已经包含一个隐含的一对一关系
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">visitor</span>(models.Model):  <span class="comment"># 访客</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>(models.Model):  <span class="comment"># 客户</span></span><br><span class="line">    visitor = models.OneToOneField(to=<span class="string">&#x27;visitor&#x27;</span>, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># 也可以写成</span></span><br><span class="line">    <span class="comment"># visitor = models.ForeignKey(to=&#x27;visitor&#x27;, unique=True, on_delete=models.CASCADE)</span></span><br></pre></td></tr></table></figure><p>OneToOneField就是在ForeignKey的基础上设置一个unique=True,只不过反向查询出的结果就一个对象，因为本质与ForeignKey类似，所以注意on_delete也是要加的。</p><p>ps：因为一对一满足“是”的关系，所以事实上，为了处理这个问题，你通常会使用继承，其中就已经包含一个隐含的一对一关系）。</p><h3 id="2、惰性关系-1"><a href="#2、惰性关系-1" class="headerlink" title="2、惰性关系"></a>2、惰性关系</h3><p>同ForeignKey一样</p><p>惰性关系的形式,在解决两个应用程序之间的循环导入依赖关系时非常有用</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(models.Model):</span><br><span class="line">    manufacturer = models.ForeignKey(</span><br><span class="line">        <span class="string">&#x27;production.Manufacturer&#x27;</span>,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="3、自关联-1"><a href="#3、自关联-1" class="headerlink" title="3、自关联"></a>3、自关联</h3><p>同ForeignKey一样</p><h3 id="4、其他-1"><a href="#4、其他-1" class="headerlink" title="4、其他"></a>4、其他</h3><p><strong>注意</strong><br>现在可以在一个模型上有多个OneToOneField类型的字段。<br>在以前的版本中，OneToOneField 字段会自动变成模型 的主键。 不过现在已经不这么做了(不过要是你愿意的话，你仍可以传递 primary_key参数来创建主键字段)。 所以一个模型中可以有多个OneToOneField 字段。</p><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line">    pub_date = models.DateField()</span><br><span class="line">    publish = models.ForeignKey(<span class="string">&quot;Publish&quot;</span>,on_delete=models.CASCADE)</span><br><span class="line">    authors = models.ManyToManyField(<span class="string">&quot;author&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publish</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">18</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">111</span>)</span><br><span class="line">    email = models.EmailField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.SmallIntegerField()</span><br><span class="line">    au_detail = models.OneToOneField(<span class="string">&quot;AuthorDetail&quot;</span>,on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthorDetail</span>(models.Model):</span><br><span class="line">    gender_choices = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&quot;保密&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    gender = models.SmallIntegerField(choices=gender_choices)</span><br><span class="line">    tel = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    addr = models.CharField(max_length=<span class="number">113</span>)</span><br><span class="line">    birthday = models.DateField()</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>1、EmailField 数据类型是邮箱格式，底层继承 CharField，进行了封装，相当于 MySQL 中的 varchar。</li><li>2、Django1.1 版本不需要联级删除：on_delete=models.CASCADE，Django2.2 需要。</li><li>3、一般不需要设置联级更新.</li><li>4、外键在一对多的多中设置：<strong>models.ForeignKey(“关联类名”, on_delete=models.CASCADE)</strong>。</li><li>5、OneToOneField = ForeignKey(…，unique=True)设置一对一。</li><li>6、若有模型类存在外键，创建数据时，要先创建外键关联的模型类的数据，不然创建包含外键的模型类的数据时，外键的关联模型类的数据会找不到。</li></ul><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p><strong>书籍表 Book</strong>：title 、 price 、 pub_date 、 publish（外键，多对一） 、 authors（多对多）</p><p><strong>出版社表 Publish</strong>：name 、 city 、 email</p><p><strong>作者表 Author</strong>：name 、 age 、 au_detail（一对一）</p><p><strong>作者详情表 AuthorDetail</strong>：gender 、 tel 、 addr 、 birthday</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/05/Django-orm2_1.png" alt="img"></p><h2 id="跨文件建立模型关系"><a href="#跨文件建立模型关系" class="headerlink" title="跨文件建立模型关系"></a>跨文件建立模型关系</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">与另外一个app中的模型建立关联是完全可以的，如何实现呢？</span><br><span class="line">在我们定义模型的文件顶部导入其他app的模型，然后在需要的地方进行关联即可，如下</span><br><span class="line"><span class="comment">## app01下的models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> app02.models <span class="keyword">import</span> ZipCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span>(models.Model):</span><br><span class="line">    <span class="comment">## ...</span></span><br><span class="line">    zip_code = models.ForeignKey(</span><br><span class="line">        ZipCode,</span><br><span class="line">        on_delete=models.SET_NULL,</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        null=<span class="literal">True</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">多对一关系的完整示例（包括增删改查）</span><br><span class="line">https://docs.djangoproject.com/zh-hans/<span class="number">3.2</span>/topics/db/examples/many_to_one/</span><br><span class="line"></span><br><span class="line">多对多关系，完整的示例（包括增删改查）</span><br><span class="line">https://docs.djangoproject.com/zh-hans/<span class="number">3.2</span>/topics/db/examples/many_to_many/</span><br><span class="line"></span><br><span class="line">一对一关系的完整示例（包括增删改查）</span><br><span class="line">https://docs.djangoproject.com/zh-hans/<span class="number">3.2</span>/topics/db/examples/one_to_one/</span><br></pre></td></tr></table></figure><h1 id="Meta选项"><a href="#Meta选项" class="headerlink" title="Meta选项"></a>Meta选项</h1><p>在模型类内部定义Meta类（可选的，所有选项都不是必须的），可以配置模型的元数据，如排序选项（ordering），数据库表名（db_table）或者人类可读的单复数名称（verbose_name 和verbose_name_plural）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    PRIORITY_CHOICES = [</span><br><span class="line">        (<span class="number">0</span>,<span class="string">&#x27;admin&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>,<span class="string">&#x27;user&#x27;</span>),</span><br><span class="line">        (<span class="number">2</span>,<span class="string">&#x27;visitor&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span>=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name=models.CharField(max_length=<span class="number">30</span>,null=<span class="literal">True</span>)</span><br><span class="line">    priority=models.IntegerField(choices=PRIORITY_CHOICES)</span><br><span class="line">    create_time=models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        <span class="comment"># 数据库中生成的表名称 默认 app名称 + 下划线 + 类名</span></span><br><span class="line">        db_table=<span class="string">&#x27;my_table&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 联合索引</span></span><br><span class="line">        index_together = [</span><br><span class="line">            (<span class="string">&quot;priority&quot;</span>, <span class="string">&quot;create_time&quot;</span>),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立联合索引推荐使用下面这种</span></span><br><span class="line">        indexes = [</span><br><span class="line">            models.Index(fields=[<span class="string">&quot;priority&quot;</span>, <span class="string">&quot;create_time&quot;</span>]), <span class="comment"># 联合索引</span></span><br><span class="line">            models.Index(fields=[<span class="string">&#x27;priority&#x27;</span>], name=<span class="string">&#x27;priority_idx&#x27;</span>), <span class="comment"># 单独的索引</span></span><br><span class="line">            <span class="comment"># 关于索引名称：如果没有提供name，Django将自动生成一个索引名称。 为了兼容不同的数据库，索引名称不能超过30个字符，不能以数字（0-9）或下划线（_）开头。</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 联合唯一索引</span></span><br><span class="line">        unique_together = ((<span class="string">&quot;name&quot;</span>, <span class="string">&quot;priority&quot;</span>),)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行Person.objects.all()</span></span><br><span class="line">        <span class="comment"># 会先按照权限priority字段降序排，权限相同则按照创建时间create_time字段升序排</span></span><br><span class="line">        ordering = (<span class="string">&#x27;-priority&#x27;</span>,<span class="string">&#x27;create_time&#x27;</span>) </span><br><span class="line"></span><br><span class="line">        <span class="comment"># admin中显示的表名称</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;哈哈哈&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># verbose_name加s</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行Person.objects.latest()</span></span><br><span class="line">        <span class="comment"># 会先按照权限priority字段降序排列，权限相同则按照id字段升序排列，然后取最后一个</span></span><br><span class="line">        get_latest_by=[<span class="string">&#x27;-priority&#x27;</span>,<span class="string">&#x27;id&#x27;</span>] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s:%s:%s&#x27;</span> %(self.name,self.priority,self.create_time)</span><br></pre></td></tr></table></figure><h1 id="多表实例-增删改查"><a href="#多表实例-增删改查" class="headerlink" title="多表实例 增删改查"></a>多表实例 增删改查</h1><h2 id="一、单表"><a href="#一、单表" class="headerlink" title="一、单表"></a>一、单表</h2><h3 id="1、-添加记录"><a href="#1、-添加记录" class="headerlink" title="1、 添加记录"></a>1、 添加记录</h3><p>准备表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">65</span>,decimal_places=<span class="number">5</span>)</span><br><span class="line">    publish = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    pub_date = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%s:%s:%s&quot;</span> %(self.<span class="built_in">id</span>,self.title,self.price)</span><br></pre></td></tr></table></figure><p>添加记录的两种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">obj=Book.objects.create(title=<span class="string">&quot;葵花宝典&quot;</span>,price=<span class="number">100</span>,publish=<span class="string">&quot;苹果出版社&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 方式二：</span></span><br><span class="line">obj=Book(title=<span class="string">&quot;九阴真经&quot;</span>,price=<span class="number">100</span>,publish=<span class="string">&quot;苹果出版社&quot;</span>)</span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure><p>添加n条记录为后续操作做准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.create(title=<span class="string">&quot;红龙梦&quot;</span>,price=<span class="number">300</span>,publish=<span class="string">&quot;66出版社&quot;</span>)</span><br><span class="line">Book.objects.create(title=<span class="string">&quot;钢弹是怎样炼成的&quot;</span>,price=<span class="number">10</span>,publish=<span class="string">&quot;新华出版社&quot;</span>)</span><br><span class="line">Book.objects.create(title=<span class="string">&quot;聊斋&quot;</span>,price=<span class="number">50</span>,publish=<span class="string">&quot;77出版社&quot;</span>)</span><br><span class="line">Book.objects.create(title=<span class="string">&quot;老女人与海王&quot;</span>,price=<span class="number">30</span>,publish=<span class="string">&quot;33出版社&quot;</span>)</span><br><span class="line">Book.objects.create(title=<span class="string">&quot;西游记&quot;</span>,price=<span class="number">43</span>,publish=<span class="string">&quot;88出版社&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2、单表查询"><a href="#2、单表查询" class="headerlink" title="2、单表查询"></a>2、单表查询</h3><p>查询API</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt; <span class="built_in">all</span>():                  查询所有结果</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">2</span>&gt; <span class="built_in">filter</span>(**kwargs):       它包含了与所给筛选条件相匹配的对象</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">3</span>&gt; get(**kwargs):          返回与所给筛选条件相匹配的对象，返回结果有且只有一个，</span><br><span class="line">                            如果符合筛选条件的对象超过一个或者没有都会抛出错误。</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">4</span>&gt; exclude(**kwargs):      它包含了与所给筛选条件不匹配的对象</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">5</span>&gt; order_by(*field):       对查询结果排序(<span class="string">&#x27;-id&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">6</span>&gt; reverse():              对且只对order_by排序的结果进行翻转</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">8</span>&gt; count():                返回数据库中匹配查询(QuerySet)的对象数量。</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">9</span>&gt; first():                返回QuerySet集中的第一个对象  </span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">10</span>&gt; last():                返回QuerySet集中的最后一个对象 </span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">11</span>&gt; exists():              如果QuerySet包含数据，就返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">12</span>&gt; values(*field):        返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列</span><br><span class="line">                            model的实例化对象，而是一个可迭代的字典序列</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">13</span>&gt; values_list(*field):   它与values()非常相似,但返回的是一个元组序列</span><br><span class="line"> </span><br><span class="line">&lt;<span class="number">14</span>&gt; distinct():            从返回结果中剔除重复纪录</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QuerySet数据类型（类似于一个列表，里面放着一些对象）</span></span><br><span class="line"><span class="comment"># 1 方法的返回值是什么</span></span><br><span class="line"><span class="comment"># 2 方法的调用者</span></span><br><span class="line"> </span><br><span class="line">===============调用者为管理器，返回值为一个记录对象=========</span><br><span class="line">obj = Book.objects.get(title=<span class="string">&quot;聊斋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj)  <span class="comment"># 结果为：Book object (5)</span></span><br><span class="line"><span class="built_in">print</span>(obj.title)</span><br><span class="line"><span class="comment"># 若找不到符合条件的记录则报错</span></span><br><span class="line">Book.objects.get(title=<span class="string">&quot;跟allen学养猪小妙招&quot;</span>)  <span class="comment"># 报错</span></span><br><span class="line"> </span><br><span class="line">===============调用者为管理器，返回值为QuerySet=========</span><br><span class="line"><span class="comment"># 1、all：</span></span><br><span class="line">book_list = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">print</span>(book_list)  <span class="comment"># 结果是一个QuerySet</span></span><br><span class="line"><span class="built_in">print</span>(book_list[<span class="number">0</span>].title)</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> book_list:</span><br><span class="line">    <span class="built_in">print</span>(obj.title)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、filter</span></span><br><span class="line">book_list = Book.objects.<span class="built_in">filter</span>(title=<span class="string">&quot;聊斋&quot;</span>)  <span class="comment"># 相当于where，还可以使用基于双下划线的模糊查询</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3、exclude</span></span><br><span class="line">book_list = Book.objects.exclude(title=<span class="string">&quot;聊斋&quot;</span>)  <span class="comment"># 除了title=&quot;聊斋&quot;之外的都留下来</span></span><br><span class="line"> </span><br><span class="line">===============调用者为QuerySet，返回值。。。=========</span><br><span class="line"><span class="comment"># 1、count(): 返回的是整型</span></span><br><span class="line">n = Book.objects.<span class="built_in">all</span>().count()</span><br><span class="line"><span class="built_in">print</span>(n)  <span class="comment"># 7</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、first()：返回的是一个记录对象             </span></span><br><span class="line">obj = Book.objects.<span class="built_in">all</span>().first()</span><br><span class="line"><span class="built_in">print</span>(obj)  </span><br><span class="line"><span class="built_in">print</span>(obj.<span class="built_in">id</span>)  <span class="comment"># 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3、last()：返回的是一个记录对象     </span></span><br><span class="line">obj = Book.objects.<span class="built_in">all</span>().last()</span><br><span class="line"><span class="built_in">print</span>(obj)  </span><br><span class="line"><span class="built_in">print</span>(obj.<span class="built_in">id</span>)  <span class="comment"># 7</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4、exists()：返回的是布尔值</span></span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(title=<span class="string">&quot;跟allen老师学算命&quot;</span>).exists()</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># False</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 5、order_by(*field)：返回的同样是QuerySet</span></span><br><span class="line">objs = Book.objects.<span class="built_in">filter</span>(id__lte=<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(objs)  <span class="comment"># QuerySet</span></span><br><span class="line"><span class="built_in">print</span>(objs.order_by(<span class="string">&#x27;price&#x27;</span>,<span class="string">&#x27;-id&#x27;</span>))  <span class="comment"># 先按照price字段升序排，若price相同则按照id字段降序排</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 6、reverse()：返回的同样是QuerySet    </span></span><br><span class="line">objs = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"> </span><br><span class="line">无效</span><br><span class="line"><span class="built_in">print</span>([obj.<span class="built_in">id</span> <span class="keyword">for</span> obj <span class="keyword">in</span> objs])</span><br><span class="line"><span class="built_in">print</span>([obj.<span class="built_in">id</span> <span class="keyword">for</span> obj <span class="keyword">in</span> objs.reverse()])  <span class="comment"># 顺序与上面保持一致</span></span><br><span class="line"> </span><br><span class="line">有效</span><br><span class="line"><span class="built_in">print</span>([obj.<span class="built_in">id</span> <span class="keyword">for</span> obj <span class="keyword">in</span> objs.order_by(<span class="string">&#x27;-id&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>([obj.<span class="built_in">id</span> <span class="keyword">for</span> obj <span class="keyword">in</span> objs.order_by(<span class="string">&#x27;-id&#x27;</span>).reverse()])  <span class="comment"># 顺序在上面的排序的基础上翻转</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 7、values(*field): 返回的同样是QuerySet</span></span><br><span class="line">objs = Book.objects.<span class="built_in">filter</span>(id__gte=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(objs.values(<span class="string">&quot;title&quot;</span>))  <span class="comment"># 返回一个QuerySet</span></span><br><span class="line"><span class="built_in">print</span>(objs.values(<span class="string">&quot;title&quot;</span>)[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>])  <span class="comment"># 红龙梦</span></span><br><span class="line"><span class="built_in">print</span>(objs.values(<span class="string">&quot;title&quot;</span>).last()[<span class="string">&#x27;title&#x27;</span>])  <span class="comment"># 西游记</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 8、values_list(*field): 返回的同样是QuerySet </span></span><br><span class="line">objs = Book.objects.<span class="built_in">filter</span>(id__gte=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(objs.values_list(<span class="string">&quot;title&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(objs.values_list(<span class="string">&quot;title&quot;</span>)[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># 红龙梦</span></span><br><span class="line"><span class="built_in">print</span>(objs.values_list(<span class="string">&quot;title&quot;</span>).last()[<span class="number">0</span>])  <span class="comment"># 西游记</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 9、distinct(): 返回的同样是QuerySet</span></span><br><span class="line">Book.objects.<span class="built_in">all</span>().distinct()  <span class="comment"># 该行代码无意义，因为每一条结果多不是重复的</span></span><br><span class="line"> </span><br><span class="line">正确用法如下</span><br><span class="line">objs = Book.objects.<span class="built_in">all</span>().values(<span class="string">&quot;price&quot;</span>).distinct()</span><br><span class="line"><span class="built_in">print</span>(objs)</span><br></pre></td></tr></table></figure><p>基于双下划线的模糊查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.<span class="built_in">filter</span>(price__in=[<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>])</span><br><span class="line">Book.objects.<span class="built_in">filter</span>(price__gt=<span class="number">100</span>)</span><br><span class="line">Book.objects.<span class="built_in">filter</span>(price__lt=<span class="number">100</span>)</span><br><span class="line">Book.objects.<span class="built_in">filter</span>(price__gte=<span class="number">100</span>)</span><br><span class="line">Book.objects.<span class="built_in">filter</span>(price__lte=<span class="number">100</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 等同于Book.objects.filter(id__gte=100,id__lte=200)</span></span><br><span class="line"><span class="comment"># 相当于where price between 100 and 200</span></span><br><span class="line">Book.objects.<span class="built_in">filter</span>(price__range=[<span class="number">100</span>,<span class="number">200</span>])  </span><br><span class="line"> </span><br><span class="line">Book.objects.<span class="built_in">filter</span>(title__contains=<span class="string">&quot;python&quot;</span>)</span><br><span class="line">Book.objects.<span class="built_in">filter</span>(title__icontains=<span class="string">&quot;python&quot;</span>)  <span class="comment"># 忽略大小写</span></span><br><span class="line">Book.objects.<span class="built_in">filter</span>(title__startswith=<span class="string">&quot;py&quot;</span>)</span><br><span class="line">Book.objects.<span class="built_in">filter</span>(title__iendswith=<span class="string">&quot;py&quot;</span>)</span><br><span class="line"> </span><br><span class="line">Book.objects.<span class="built_in">filter</span>(pub_date__lte=<span class="string">&quot;2021-02-23 17:51:00&quot;</span>)</span><br><span class="line">Book.objects.<span class="built_in">filter</span>(pub_date__minute=<span class="string">&quot;38&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3、单表delete"><a href="#3、单表delete" class="headerlink" title="3、单表delete"></a>3、单表delete</h3><p>删除delete：调用者只能是QuerySet或者单个一个记录对象</p><p><em># 批量删除**<br>\</em>objs = Book.objects.filter(id__in=[1,3,5])*<br>*objs.delete()*<br><strong></strong><br><strong># 删除单一记录</strong><br>*objs = Book.objects.filter(id=6)*<br>*obj=objs[0]*<br>*obj.delete()*<br><em>*</em> objs.last().delete()</p><p>在 Django 删除对象时，会模仿 SQL 约束 ON DELETE CASCADE 的行为，换句话说，删除一个对象时也会删除与它相关联的外键对象。例如：</p><p>b = Blog.objects.get(pk=1)<em><br><strong># This will delete the Blog and all of its Entry objects.</strong></em> b.delete()</p><p>要注意的是： delete() 方法是 QuerySet 上的方法，但并不适用于 Manager 本身。这是一种保护机制，是为了避免意外地调用 Entry.objects.delete() 方法导致 所有的 记录被误删除。如果你确认要删除所有的对象，那么你必须显式地调用：</p><p>Entry.objects.all().delete()　</p><p>如果不想级联删除，可以设置为:</p><p>pubHouse = models.ForeignKey(to=’Publisher’, on_delete=models.SET_NULL, blank=True, null=True)</p><h3 id="4、单表update"><a href="#4、单表update" class="headerlink" title="4、单表update"></a>4、单表update</h3><p>修改update：调用者只能是QuerySet，返回值为int</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objs = Book.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">7</span>)</span><br><span class="line">rows=objs.update(title=<span class="string">&quot;xxx&quot;</span>)    </span><br><span class="line"><span class="built_in">print</span>(rows)</span><br><span class="line"> </span><br><span class="line">Book.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;跟allen学算命&#x27;</span>).first().update(name=<span class="string">&#x27;大家多能成神仙&#x27;</span>)  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><p>update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录update()方法会返回一个整型数值，表示受影响的记录条数。</p><h2 id="二、多表"><a href="#二、多表" class="headerlink" title="二、多表"></a>二、多表</h2><p>准备多对多、一对多、一对一关系如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish_date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 阅读数</span></span><br><span class="line">    <span class="comment"># read_num=models.IntegerField(default=0)</span></span><br><span class="line">    <span class="comment"># 评论数</span></span><br><span class="line">    <span class="comment"># comment_num=models.IntegerField(default=0)</span></span><br><span class="line"> </span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,on_delete=models.CASCADE)</span><br><span class="line">    authors=models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span>(models.Model):</span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    author_detail = models.OneToOneField(to=<span class="string">&#x27;AuthorDatail&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,unique=<span class="literal">True</span>,on_delete=models.CASCADE)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthorDatail</span>(models.Model):</span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    telephone = models.BigIntegerField()</span><br><span class="line">    birthday = models.DateField()</span><br><span class="line">    addr = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publish</span>(models.Model):</span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    email = models.EmailField()</span><br></pre></td></tr></table></figure><p>生成的表如下：</p><p><img src="https://allenlin.com/wp-content/uploads/2022/04/wps18.jpg" alt="img"></p><h3 id="1、添加记录"><a href="#1、添加记录" class="headerlink" title="1、添加记录"></a>1、添加记录</h3><p>多对一关系添加：app01_book与app01_publish</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 先创建出版社</span></span><br><span class="line">publish_obj = Publish.objects.create(name=<span class="string">&quot;666出版社&quot;</span>, city=<span class="string">&quot;上海&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 再创建书籍与出版社关联，具体有两种方式</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">Book.objects.create(name=<span class="string">&quot;跟allen学算命&quot;</span>, price=<span class="number">3</span>, publish=publish_obj)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">book_obj = Book(name=<span class="string">&quot;跟allen学风水&quot;</span>, price=<span class="number">5</span>)</span><br><span class="line">book_obj.publish_id = publish_obj.nid</span><br><span class="line">book_obj.save()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 思考：</span></span><br><span class="line">book_obj.publish与book_obj.publish_id是什么？</span><br></pre></td></tr></table></figure><p>清理掉多对一的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以只删掉一个书籍对象</span></span><br><span class="line">Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;跟allen学算命&quot;</span>).delete()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 因为级联删除的存在，所以删出一个版社对象，对应的书籍对象会一并清除</span></span><br><span class="line">Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;666出版社&quot;</span>).delete()</span><br></pre></td></tr></table></figure><p>一对一关系添加（与多对一一样）：app01_autor与app01_authordatail</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建作者详情</span></span><br><span class="line">obj = AuthorDatail.objects.create(telephone=<span class="number">1861131111</span>,birthday=<span class="string">&quot;2011-11-11&quot;</span>,addr=<span class="string">&quot;水帘洞&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 再创建作者信息</span></span><br><span class="line">Author.objects.create(name=<span class="string">&#x27;allen&#x27;</span>,age=<span class="number">18</span>,author_detail=obj)</span><br></pre></td></tr></table></figure><p>清理掉一对一关系（同多对一一样）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议删作者时直接删除作者详情，这样便级联删除了作者</span></span><br><span class="line">AuthorDatail.objects.<span class="built_in">filter</span>(nid=<span class="number">1</span>).delete()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果只删作者，作者详情当然还是会存在的</span></span><br><span class="line">Author.objects.<span class="built_in">filter</span>(nid=<span class="number">1</span>).delete()</span><br></pre></td></tr></table></figure><p>多对多关系添加：app01_autor,app01_book_autors,app01_book</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">=====下述记录如果已经存在了就不用创建了，直接过滤出来用就可以了，如果删掉了，那就重新建一遍</span><br><span class="line"><span class="comment"># 1、添加作者及其详情</span></span><br><span class="line">obj = AuthorDatail.objects.create(telephone=<span class="number">1861131111</span>,birthday=<span class="string">&quot;2011-11-11&quot;</span>,addr=<span class="string">&quot;水帘洞&quot;</span>)</span><br><span class="line">Author.objects.create(name=<span class="string">&#x27;allen&#x27;</span>,age=<span class="number">18</span>,author_detail=obj)</span><br><span class="line"> </span><br><span class="line">obj = AuthorDatail.objects.create(telephone=<span class="number">1361131111</span>,birthday=<span class="string">&quot;2022-12-12&quot;</span>,addr=<span class="string">&quot;盘丝洞&quot;</span>)</span><br><span class="line">Author.objects.create(name=<span class="string">&#x27;Tom&#x27;</span>,age=<span class="number">18</span>,author_detail=obj)</span><br><span class="line"> </span><br><span class="line">obj = AuthorDatail.objects.create(telephone=<span class="number">1761131111</span>,birthday=<span class="string">&quot;2013-10-10&quot;</span>,addr=<span class="string">&quot;金光洞&quot;</span>)</span><br><span class="line">Author.objects.create(name=<span class="string">&#x27;Jack&#x27;</span>,age=<span class="number">18</span>,author_detail=obj)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、添加书籍</span></span><br><span class="line">publish_obj = Publish.objects.create(name=<span class="string">&quot;666出版社&quot;</span>, city=<span class="string">&quot;上海&quot;</span>)</span><br><span class="line">Book.objects.create(name=<span class="string">&quot;跟allen学算命&quot;</span>, price=<span class="number">3</span>, publish=publish_obj)</span><br><span class="line">Book.objects.create(name=<span class="string">&quot;跟allen学风水&quot;</span>, price=<span class="number">3</span>, publish_id=publish_obj.nid)</span><br><span class="line"> </span><br><span class="line">===添加作者与书的多对多关系</span><br><span class="line"><span class="comment"># 过滤出书籍对象</span></span><br><span class="line">book_obj1 = Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;跟allen学算命&quot;</span>).first()</span><br><span class="line">book_obj2 = Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;跟allen学风水&quot;</span>).first()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 过滤出作者对象</span></span><br><span class="line">allen = Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;allen&quot;</span>).first()</span><br><span class="line">tom = Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;Tom&quot;</span>).first()</span><br><span class="line">jack = Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;Jack&quot;</span>).first()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加关系</span></span><br><span class="line">book_obj1.authors.add(allen,tom,jack)</span><br><span class="line">book_obj2.authors.add(allen,jack)</span><br><span class="line">ps: 也可以直接传<span class="built_in">id</span></span><br><span class="line">book_obj1.authors.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  <span class="comment"># 或者用形式*[1,2,3]</span></span><br><span class="line"> </span><br><span class="line">查看app01_book_authors记录如下</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">| <span class="built_in">id</span> | book_id | author_id |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">|  <span class="number">1</span> |       <span class="number">1</span> |         <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |       <span class="number">1</span> |         <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |       <span class="number">1</span> |         <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |       <span class="number">2</span> |         <span class="number">1</span> |</span><br><span class="line">|  <span class="number">5</span> |       <span class="number">2</span> |         <span class="number">3</span> |</span><br><span class="line">+----+---------+-----------+</span><br></pre></td></tr></table></figure><p>清理掉多对多关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># remove：下面三种方式都可以</span></span><br><span class="line">book_obj1.authors.remove(allen,tom)</span><br><span class="line">book_obj1.authors.remove(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">book_obj1.authors.remove(*[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"> </span><br><span class="line">查看app01_book_authors记录如下</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">| <span class="built_in">id</span> | book_id | author_id |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">|  <span class="number">3</span> |       <span class="number">1</span> |         <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |       <span class="number">2</span> |         <span class="number">1</span> |</span><br><span class="line">|  <span class="number">5</span> |       <span class="number">2</span> |         <span class="number">3</span> |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line"> </span><br><span class="line"><span class="comment"># clear(): 清空被关联对象集合</span></span><br><span class="line">book_obj2.authors.clear()</span><br><span class="line"> </span><br><span class="line">查看app01_book_authors记录如下</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">| <span class="built_in">id</span> | book_id | author_id |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line">|  <span class="number">3</span> |       <span class="number">1</span> |         <span class="number">3</span> |</span><br><span class="line">+----+---------+-----------+</span><br><span class="line"> </span><br><span class="line"><span class="comment"># set(): 先清空再设置，只能传入一个序列，里面包含要添加的作者对象或者作者对象的id都可以</span></span><br><span class="line">book_obj1.authors.<span class="built_in">set</span>([allen,<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="2、查询记录"><a href="#2、查询记录" class="headerlink" title="2、查询记录"></a>2、查询记录</h3><h4 id="1-多表查询的法则提炼如下"><a href="#1-多表查询的法则提炼如下" class="headerlink" title="1.多表查询的法则提炼如下"></a>1.多表查询的法则提炼如下</h4><p>• 第一步：先搞清楚是正向查询还是反向查询</p><p>关联字段所在的表可以称之为源表，被关联的表称之为目标表，如此，正向反向一目了然了</p><p>• 第二步</p><p><em># 基于对象的查询相当于子查询（其实本质是分步查询）**<br>\</em> 正查用关联字段*<br>* 反查用模型名，但如果反查的结果有多个值则要加_set*<br><strong></strong> # 基于双下划线的查询相当于join链表<strong><br>* 正查用关联字段*</strong><br>* 反查用模型名**</p><h4 id="2-基于对象的子查询"><a href="#2-基于对象的子查询" class="headerlink" title="2.基于对象的子查询"></a>2.基于对象的子查询</h4><p>多对一查询：app01_book与app01_publish</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向案例：查询”跟allen学算命“是哪个出版社出版的</span></span><br><span class="line">book_obj=Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;跟allen学算命&quot;</span>).first()</span><br><span class="line"><span class="built_in">print</span>(book_obj.publish.name)  <span class="comment"># 正向查询直接用关联字段，即publish即可</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 反向案例：查询”666出版社“出版的所有书籍</span></span><br><span class="line">publish_obj = Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;666出版社&quot;</span>).first()</span><br><span class="line"><span class="built_in">print</span>(publish_obj.book_set.<span class="built_in">all</span>())  <span class="comment"># 反向查询用模型名，结果有多个，所有还有加_set，返回QuerySet</span></span><br></pre></td></tr></table></figure><p>一对一查询：app01_autor与app01_authordatail</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向案例：查询”allen“的手机号</span></span><br><span class="line">allen=Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;allen&quot;</span>).first()</span><br><span class="line"><span class="built_in">print</span>(allen.author_detail.telephone)  <span class="comment"># 正向查询直接用关联字段，即author_detail即可</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 反向案例：查询”nid=1的详情信息对应的作者名字“</span></span><br><span class="line">obj = AuthorDatail.objects.<span class="built_in">filter</span>(nid=<span class="number">1</span>).first()</span><br><span class="line"><span class="built_in">print</span>(obj.author.name)  <span class="comment"># 反向查询用模型名，结果只有一个，所有author后无需加_set</span></span><br></pre></td></tr></table></figure><p>多对多查询：app01_autor,app01_book_autors,app01_book</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向案例：查询”跟allen学算命“的所有作者</span></span><br><span class="line">allen = Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;跟allen学算命&quot;</span>).first()</span><br><span class="line"><span class="built_in">print</span>(allen.authors.<span class="built_in">all</span>())  <span class="comment"># 正向查询直接用字段authors即可，而authors有多个，所以需要加all()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 反向案例：查询”allen“都出了哪些书</span></span><br><span class="line">allen = Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;allen&quot;</span>).first()</span><br><span class="line"><span class="built_in">print</span>(allen.book_set.<span class="built_in">all</span>())  <span class="comment"># 反向查询用模型名，结果有多个，所有还有加_set，返回QuerySet</span></span><br></pre></td></tr></table></figure><h4 id="3-基于双下划线的链表查询"><a href="#3-基于双下划线的链表查询" class="headerlink" title="3.基于双下划线的链表查询"></a>3.基于双下划线的链表查询</h4><p>多对一查询：app01_book与app01_publish</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、查询”跟allen学算命“是哪个出版社出版的</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;跟allen学算命&quot;</span>).values_list(<span class="string">&quot;publish__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;666出版社&#x27;,)]&gt;</span></span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res = Publish.objects.<span class="built_in">filter</span>(book__name=<span class="string">&quot;跟allen学算命&quot;</span>).values_list(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;city&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;666出版社&#x27;, &#x27;上海&#x27;)]&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、查询”666出版社“出版的所有书籍</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res = Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;666出版社&quot;</span>).values_list(<span class="string">&quot;book__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;跟allen学算命&#x27;,), (&#x27;跟allen学风水&#x27;,)]&gt;</span></span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(publish__name=<span class="string">&quot;666出版社&quot;</span>).values_list(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># &lt;QuerySet [(&#x27;跟allen学算命&#x27;,), (&#x27;跟allen学风水&#x27;,)]&gt;</span></span><br></pre></td></tr></table></figure><p>一对一查询：app01_autor与app01_authordatail</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、查询”allen“的手机号</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res = Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;allen&quot;</span>).values_list(<span class="string">&quot;author_detail__telephone&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(1861131111,)]&gt;</span></span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res = AuthorDatail.objects.<span class="built_in">filter</span>(author__name=<span class="string">&quot;allen&quot;</span>).values(<span class="string">&quot;telephone&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 名字的大小写不重要，因为mysql中的查询默认也忽略大小写</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、查询”nid=1的详情信息对应的作者名字“</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res = Author.objects.<span class="built_in">filter</span>(author_detail__nid=<span class="number">1</span>).values_list(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;allen&#x27;,)]&gt;</span></span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res = AuthorDatail.objects.<span class="built_in">filter</span>(nid=<span class="number">1</span>).values_list(<span class="string">&quot;author__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;allen&#x27;,)]&gt;</span></span><br></pre></td></tr></table></figure><p>多对多查询：app01_autor,app01_book_autors,app01_book</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向案例：查询”跟allen学算命“的所有作者</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;跟allen学算命&quot;</span>).values_list(<span class="string">&quot;authors__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;allen&#x27;,), (&#x27;Tom&#x27;,), (&#x27;Jack&#x27;,)]&gt;</span></span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res = Author.objects.<span class="built_in">filter</span>(book__name=<span class="string">&quot;跟allen学算命&quot;</span>).values_list(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;allen&#x27;,), (&#x27;Tom&#x27;,), (&#x27;Jack&#x27;,)]&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查询”allen“都出了哪些书</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res = Author.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;allen&quot;</span>).values_list(<span class="string">&quot;book__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;跟allen学算命&#x27;,), (&#x27;跟allen学风水&#x27;,)]&gt;</span></span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(authors__name=<span class="string">&quot;allen&quot;</span>).values_list(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [(&#x27;跟allen学算命&#x27;,), (&#x27;跟allen学风水&#x27;,)]&gt;</span></span><br></pre></td></tr></table></figure><p>如果有必要，你可以一直连续跨表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、查询“666出版社”出版过的所有书籍及期作者名字</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(publish__name=<span class="string">&quot;666出版社&quot;</span>).values_list(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;authors__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line">&lt;QuerySet [(<span class="string">&#x27;跟allen学算命&#x27;</span>, <span class="string">&#x27;allen&#x27;</span>), (<span class="string">&#x27;跟allen学算命&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>), (<span class="string">&#x27;跟allen学算命&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>), (<span class="string">&#x27;跟allen学风水&#x27;</span>, <span class="string">&#x27;allen&#x27;</span>), (<span class="string">&#x27;跟allen学风水&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>)]&gt;</span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res = Publish.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;666出版社&quot;</span>).values_list(<span class="string">&quot;book__name&quot;</span>,<span class="string">&quot;book__authors__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、2011年出生的作者出版过的所有书籍名称以及出版社名称</span></span><br><span class="line">===&gt;正查</span><br><span class="line">res=Book.objects.<span class="built_in">filter</span>(authors__author_detail__birthday__year=<span class="number">2011</span>).values_list(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;publish__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">&lt;QuerySet [(<span class="string">&#x27;跟allen学算命&#x27;</span>, <span class="string">&#x27;666出版社&#x27;</span>), (<span class="string">&#x27;跟allen学风水&#x27;</span>, <span class="string">&#x27;666出版社&#x27;</span>)]&gt;</span><br><span class="line"> </span><br><span class="line">===&gt;反查</span><br><span class="line">res=AuthorDatail.objects.<span class="built_in">filter</span>(birthday__year=<span class="string">&quot;2011&quot;</span>).values_list(<span class="string">&quot;author__book__name&quot;</span>,<span class="string">&quot;author__book__publish__name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="三、查询相关参数补充"><a href="#三、查询相关参数补充" class="headerlink" title="三、查询相关参数补充"></a>三、查询相关参数补充</h2><h3 id="1、多对对参数：symmetrical"><a href="#1、多对对参数：symmetrical" class="headerlink" title="1、多对对参数：symmetrical"></a>1、多对对参数：symmetrical</h3><p>仅用于多对多自关联时，指定内部是否创建反向操作的字段。默认为True。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    friends = models.ManyToManyField(<span class="string">&quot;self&quot;</span>)</span><br><span class="line">此时，person对象就没有person_set属性。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    friends = models.ManyToManyField(<span class="string">&quot;self&quot;</span>, symmetrical=<span class="literal">False</span>)</span><br><span class="line">此时，person对象现在就可以使用person_set属性进行反向查询。</span><br></pre></td></tr></table></figure><h3 id="2、foreign-key参数：related-name与related-query-name"><a href="#2、foreign-key参数：related-name与related-query-name" class="headerlink" title="2、foreign key参数：related_name与related_query_name"></a>2、foreign key参数：related_name与related_query_name</h3><p>related_name = “xxx”<br>反向：小写模型名_set 换成 xxx</p><p>related_query_name = “xxx”<br>反向：小写模型名_set 换成 xxx_set</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Classes</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    theclass = models.ForeignKey(to=<span class="string">&quot;Classes&quot;</span>)</span><br><span class="line"> </span><br><span class="line">当我们要查询某个班级关联的所有学生（反向查询）时，我们会这么写：</span><br><span class="line"> </span><br><span class="line">models.Classes.objects.first().student_set.<span class="built_in">all</span>()</span><br><span class="line">当我们在ForeignKey字段中添加了参数 related_name 后，</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    theclass = models.ForeignKey(to=<span class="string">&quot;Classes&quot;</span>, related_name=<span class="string">&quot;students&quot;</span>)</span><br><span class="line">当我们要查询某个班级关联的所有学生（反向查询）时，我们会这么写：</span><br><span class="line"> </span><br><span class="line">models.Classes.objects.first().students.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><h2 id="四、-聚合与分组查询"><a href="#四、-聚合与分组查询" class="headerlink" title="四、\聚合与分组查询**"></a>四、<strong><em>\</em>聚合与分组查询**</strong></h2><h3 id="1、annotate"><a href="#1、annotate" class="headerlink" title="1、annotate"></a>1、annotate</h3><p>分组查询annotate等同于mysql的group by，但是annotate的分组要分两种情况讨论</p><p>1、默认以表的主键字段分组</p><p>管理器objects左边的那个模型是谁就以谁的主键字段作为分组依据，例如Book.objects.annotate()，则按照Book的主键字段分组</p><p>举例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、每本书的作者个数</span></span><br><span class="line">res=Book.objects.annotate(authors_num=Count(<span class="string">&#x27;authors&#x27;</span>)).values(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;authors_num&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line">原生sql分析：</span><br><span class="line">会先链接表app01_book和app01_authors，然后再按照app01_book表的主键字段分组，此处app01_book表的主键字段为nid</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、每个出版社卖的最便宜的那本书的价格</span></span><br><span class="line">res=Publish.objects.annotate(x=Min(<span class="string">&quot;book__price&quot;</span>)).values(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [&#123;&#x27;x&#x27;: Decimal(&#x27;2.00&#x27;)&#125;]&gt;</span></span><br><span class="line"> </span><br><span class="line">原生sql分析：同上</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3、统计不止一个作者的图书</span></span><br><span class="line">res = Book.objects.annotate(n=Count(<span class="string">&quot;authors&quot;</span>)).<span class="built_in">filter</span>(n__gt=<span class="number">1</span>).values_list(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4、查询每个作者的书的总价格</span></span><br><span class="line">res=Author.objects.annotate(s=Sum(<span class="string">&quot;book__price&quot;</span>)).values(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line">原生sql分析:</span><br><span class="line">会先链接表app01_author、app01_book_authors、app01_book</span><br><span class="line">然后再按照app01_author表的主键字段分组，此处为app01_author.nid</span><br></pre></td></tr></table></figure><p>2、如果想按照指定的字段分组，则需要引入values()</p><p>annotate()前面的出现了values()，就会以values()中指定的字段分组<br>如果没有，就会默认按照模型的主键字段分组，例如<br>Book.objects.values(“price”).annotate() # 按照Book模型的price字段分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、统计每年出版的书个数</span></span><br><span class="line">res=Book.objects.values(<span class="string">&quot;publish_date__year&quot;</span>).annotate(n=Count(<span class="string">&quot;nid&quot;</span>)).values(<span class="string">&quot;publish_date__year&quot;</span>,<span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;publish_date__year&#x27;</span>: <span class="number">2021</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;publish_date__year&#x27;</span>: <span class="number">2022</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">1</span>&#125;]&gt;</span><br></pre></td></tr></table></figure><p>如果我们想统计哪一年哪一月出版的书个数，需要用到date_format函数，此时就需要调用extra来执行date_format了，如下，注意%要连续写两个，第一个代表取消第二%的特殊意义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res=Book.objects.extra(select=&#123;<span class="string">&quot;y_m&quot;</span>:<span class="string">&quot;date_format(publish_date,&#x27;%%Y-%%m&#x27;)&quot;</span>&#125;).values(<span class="string">&quot;y_m&quot;</span>).annotate(n=Count(<span class="string">&quot;nid&quot;</span>)).values(<span class="string">&quot;y_m&quot;</span>,<span class="string">&quot;n&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(res)  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;y_m&#x27;</span>: <span class="string">&#x27;2021-02&#x27;</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;y_m&#x27;</span>: <span class="string">&#x27;2022-02&#x27;</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">1</span>&#125;]&gt;</span><br></pre></td></tr></table></figure><p>ps：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在严格模式下（ONLY_FULL_GROUP_BY）分组之后默认只能获取分组依据，若查询了非分组字段，会导致错误，需要修改数据库模式：</span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置sql_mole如下操作(我们可以去掉ONLY_FULL_GROUP_BY模式)：</span></span><br><span class="line">mysql&gt; <span class="built_in">set</span> <span class="keyword">global</span> sql_mode=<span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="五、F查询与Q查询"><a href="#五、F查询与Q查询" class="headerlink" title="五、F查询与Q查询"></a>五、F查询与Q查询</h2><h3 id="1、-aggregate"><a href="#1、-aggregate" class="headerlink" title="1、 aggregate"></a>1、 aggregate</h3><p>若想把整张表当成一个组来使用聚合函数，应该调用aggregate</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、先导入聚合函数</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Max, Min, Avg, Sum, Count</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">小窍门：</span></span><br><span class="line"><span class="string">只要是跟数据库相关的模块基本都在django.db.models里面</span></span><br><span class="line"><span class="string">如果没有那么应该在django.db里</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、查询所有作者的最大nid、最小年龄、平均年龄、年龄之和、作者个数</span></span><br><span class="line"> </span><br><span class="line">res = Author.objects.aggregate(</span><br><span class="line">        Max(<span class="string">&quot;age&quot;</span>),</span><br><span class="line">        Min(<span class="string">&quot;age&quot;</span>), </span><br><span class="line">        Avg(<span class="string">&quot;age&quot;</span>), </span><br><span class="line">        Sum(<span class="string">&quot;age&quot;</span>), </span><br><span class="line">        Count(<span class="string">&quot;nid&quot;</span>)</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 调用的sql为：select avg(&quot;age&quot;),max(&quot;nid&quot;),... from app01_author;</span></span><br><span class="line">&#123;<span class="string">&#x27;age__max&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;age__min&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;age__avg&#x27;</span>: <span class="number">20.0</span>, <span class="string">&#x27;age__sum&#x27;</span>: <span class="number">60</span>, <span class="string">&#x27;nid__count&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3、也可以指定key值</span></span><br><span class="line">res = Author.objects.aggregate(</span><br><span class="line">        x=Max(<span class="string">&quot;age&quot;</span>),</span><br><span class="line">        y=Min(<span class="string">&quot;age&quot;</span>),</span><br><span class="line">    )</span><br><span class="line"><span class="built_in">print</span>(res) </span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2、F查询"><a href="#2、F查询" class="headerlink" title="2、F查询"></a>2、F查询</h3><p>F查询够帮你直接获取到表中的某个字段对应的值，具体应用如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改模型Book增加阅读数与评论数字段，然后重新迁移数据库，新增好记录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    nid = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">5</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    publish_date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 阅读数</span></span><br><span class="line">    read_num=models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 评论数</span></span><br><span class="line">    comment_num=models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    publish = models.ForeignKey(to=<span class="string">&#x27;Publish&#x27;</span>,to_field=<span class="string">&#x27;nid&#x27;</span>,on_delete=models.CASCADE)</span><br><span class="line">    authors=models.ManyToManyField(to=<span class="string">&#x27;Author&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"><span class="comment"># 1、查询阅评论数大于阅读数的书籍名</span></span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(comment_num__gt=F(<span class="string">&quot;read_num&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、将所有书的价格在原来的基础上增加50元</span></span><br><span class="line">Book.objects.update(price=F(<span class="string">&quot;price&quot;</span>)+<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>注意，针对数字运算，F可以直接与数字进行数学运算，但如果我们想拼接字符串，则需要引入Concat并配合Value一起实现，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3、将所有书籍的名称后面加爆款两个字</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Concat</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Value, F</span><br><span class="line"> </span><br><span class="line">Book.objects.update(name=Concat(F(<span class="string">&#x27;name&#x27;</span>), Value(<span class="string">&quot;爆款&quot;</span>)))</span><br><span class="line"><span class="comment"># Book.objects.update(name=F(&#x27;name&#x27;) + &quot;爆款&quot;)  # 错误，所有书的名字都会被改为0</span></span><br></pre></td></tr></table></figure><h3 id="3、Q查询"><a href="#3、Q查询" class="headerlink" title="3、Q查询"></a>3、Q查询</h3><p>对于filter()方法内逗号分隔开的多个条件，都是and关系，如果想用or或者not关系，则需要使用Q</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"> </span><br><span class="line">Book.objects.<span class="built_in">filter</span>(Q(nid__gte=<span class="number">3</span>), Q(nid__lte=<span class="number">5</span>))  <span class="comment"># 还是and关系</span></span><br><span class="line">Book.objects.<span class="built_in">filter</span>(Q(nid__lte=<span class="number">3</span>) | Q(nid__gte=<span class="number">5</span>))  <span class="comment"># or关系</span></span><br><span class="line"> </span><br><span class="line">Book.objects.<span class="built_in">filter</span>(~Q(nid__gt=<span class="number">2</span>))  <span class="comment"># ~ 等同于在条件前加了not  代表: ! nid&gt;2即nid&lt;=2</span></span><br><span class="line">Book.objects.<span class="built_in">filter</span>(~Q(nid__gt=<span class="number">2</span>) | Q(nid__gte=<span class="number">5</span>))  <span class="comment">#  代表nid&lt;=2 or nid&gt;=5</span></span><br></pre></td></tr></table></figure><p>Q查询的高阶用法：能够以字符串作为查询字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">q = Q()</span><br><span class="line">q.children.append((<span class="string">&#x27;nid__gt&#x27;</span>, <span class="number">2</span>))  <span class="comment"># 条件中引用的字段为字符串类型</span></span><br><span class="line">q.children.append((<span class="string">&#x27;price__lt&#x27;</span>, <span class="number">50</span>))</span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(q)  <span class="comment"># filter内可以直接放q对象，默认还是and关系</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line">q = Q()</span><br><span class="line">q.connector = <span class="string">&#x27;or&#x27;</span></span><br><span class="line">q.children.append((<span class="string">&#x27;nid__lte&#x27;</span>, <span class="number">2</span>))</span><br><span class="line">q.children.append((<span class="string">&#x27;nid__gte&#x27;</span>, <span class="number">5</span>))</span><br><span class="line">res = Book.objects.<span class="built_in">filter</span>(q)  <span class="comment"># 此时是or关系</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 那什么场景下，我们查询条件中的字段是字符串类型呢？</span></span><br><span class="line"><span class="comment"># 比如我们制作一个搜索功能，我们需要根据用户输入搜索字段完成查询，而用户输入的都是字符串类型，此时就用到了Q的高阶用法</span></span><br></pre></td></tr></table></figure><h1 id="QuerySet对象与查询优化"><a href="#QuerySet对象与查询优化" class="headerlink" title="QuerySet对象与查询优化"></a>QuerySet对象与查询优化</h1><h2 id="一、QuerySet对象"><a href="#一、QuerySet对象" class="headerlink" title="一、QuerySet对象"></a>一、QuerySet对象</h2><p>Django的ORM中存在查询集的概念。</p><p>查询集，也称查询结果集，即QuerySet，表示从数据库中获取的对象集合。</p><p>当调用如下过滤器方法时，Django会返回查询集（与列表类似，但不是简单的列表）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">all</span>()：返回所有数据。</span><br><span class="line"> </span><br><span class="line"><span class="built_in">filter</span>()：返回满足条件的数据。</span><br><span class="line"> </span><br><span class="line">exclude()：返回满足条件之外的数据。</span><br><span class="line"> </span><br><span class="line">order_by()：对结果进行排序。</span><br></pre></td></tr></table></figure><p>查询集有诸多特性，我们来一一了解它们</p><h3 id="1、可切片"><a href="#1、可切片" class="headerlink" title="1、可切片"></a>1、可切片</h3><p>可以使用Python 的切片语法来限制<em>查询集</em>记录的数目，它等同于SQL 的<em>LIMIT</em> 和<em>OFFSET</em> 子句 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res = Book.objects.<span class="built_in">all</span>()[:<span class="number">5</span>]  <span class="comment"># limit 5</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [&lt;Book: book1&gt;, ..., &lt;Book: book5&gt;]&gt;</span></span><br><span class="line"> </span><br><span class="line">res = Book.objects.<span class="built_in">all</span>()[<span class="number">5</span>:<span class="number">7</span>]   <span class="comment"># LIMIT 2 OFFSET 5，偏移5所以从6开始，到7结束即limit 2</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;QuerySet [&lt;Book: book6&gt;, &lt;Book: book7&gt;]&gt;</span></span><br></pre></td></tr></table></figure><p>不支持负的索引（例如<em>Book.objects.all()[-1]</em>）。</p><p><strong><em>\</em>强调：不能把QuerySet单纯地当成python中的列表，它们还是有区别的。**</strong></p><h3 id="2、可迭代"><a href="#2、可迭代" class="headerlink" title="2、可迭代"></a>2、可迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(book.name)</span><br></pre></td></tr></table></figure><h3 id="3、惰性查询"><a href="#3、惰性查询" class="headerlink" title="3、惰性查询"></a>3、惰性查询</h3><p><em>查询集</em> 是惰性执行的 —— 创建<em>查询集</em>不会带来任何数据库的访问。你可以将过滤器保持一整天，直到<em>查询集</em> 需要求值时，Django 才会真正运行这个查询。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query_res = Book.objects.<span class="built_in">all</span>()  <span class="comment"># 不会查询数据库，终端也并无sql日志打印</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(query_res)  <span class="comment"># 此时才会查询数据库，在开启sql日志功能后，可以在终端看到执行的原生sql</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> query_res:</span><br><span class="line">    <span class="built_in">print</span>(book.name)  <span class="comment"># 此时会再次查询数据库</span></span><br></pre></td></tr></table></figure><p>一般来说，只有在“请求”<em>查询集</em> 的结果时才会到数据库中去获取它们。当你确实需要结果时，<em>查询集</em> 通过访问数据库来<strong>求值</strong></p><h3 id="4、缓存机制"><a href="#4、缓存机制" class="headerlink" title="4、缓存机制"></a>4、缓存机制</h3><p>每个<em>查询集</em>都包含一个缓存来最小化对数据库的访问。理解它是如何工作的将让你编写最高效的代码。</p><p>在一个新创建的<em>查询集</em>中，缓存为空。</p><p>当我们首次对<em>查询集</em>进行求值时–同时发生数据库查询 ，Django 将查询的结果保存到<em>查询集</em>的缓存中并返回明确请求的结果。接下来对该<em>查询集</em> 的求值将重用缓存的结果。</p><p>请牢记这个缓存行为，因为对<em>查询集</em>使用不当的话，它会坑你的。</p><p>例如，下面的两条语句查出的都是所有的书籍，但是每条都创建了新的<em>查询集</em>，然后各自对各自的查询集求值，这存在两大问题</p><p>• 1、相同的数据库查询将执行两次，显然倍增了你的数据库负载。</p><p>• 2、还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有Article被添加进来或删除掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([book.name <span class="keyword">for</span> book <span class="keyword">in</span> Book.objects.<span class="built_in">all</span>()])</span><br><span class="line"><span class="built_in">print</span>([book.price <span class="keyword">for</span> book <span class="keyword">in</span> Book.objects.<span class="built_in">all</span>()])</span><br></pre></td></tr></table></figure><p>为了避免上述问题，只需保存<em>查询集</em>并重新使用它，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、先保存结果集</span></span><br><span class="line">query_res = Book.objects.<span class="built_in">all</span>()  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、然后再对结果集进行求值</span></span><br><span class="line"><span class="built_in">print</span>([book.name <span class="keyword">for</span> book <span class="keyword">in</span> query_res])  <span class="comment"># 首次对查询集求值，会查询数据库并缓存</span></span><br><span class="line"><span class="built_in">print</span>([book.price <span class="keyword">for</span> book <span class="keyword">in</span> query_res]) <span class="comment"># 命中缓存，无需查询数据库</span></span><br></pre></td></tr></table></figure><h3 id="5、何时查询集不会被缓存"><a href="#5、何时查询集不会被缓存" class="headerlink" title="5、何时查询集不会被缓存?"></a>5、何时查询集不会被缓存?</h3><p>1、只有在对查询集求值后才会缓存</p><p>如下操作都算是在对查询集求值，它们会使得全部的查询集被求值并填充到缓存中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[book <span class="keyword">for</span> book <span class="keyword">in</span> query_res]</span><br><span class="line"><span class="built_in">bool</span>(query_res)</span><br><span class="line">any_obj <span class="keyword">in</span> query_res</span><br><span class="line"><span class="built_in">list</span>(query_res)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> query_res:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;哪怕只遍历一次，也算是对查询集求值了，会缓存Book.objects.all()的所有结果&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>2、单纯的打印结果集不算是对查询集求值，所以不会被缓存，每次打印都会引发新的数据库查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query_res = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">print</span>(query_res)  <span class="comment"># 查询数据库</span></span><br><span class="line"><span class="built_in">print</span>(query_res)  <span class="comment"># 查询数据库</span></span><br></pre></td></tr></table></figure><p>3、使用切片或索引来限制查询集也不算是对查询集求值，所以也不会被缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query_res = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">print</span>(query_res[<span class="number">5</span>])  <span class="comment"># 查询数据库</span></span><br><span class="line"><span class="built_in">print</span>(query_res[<span class="number">3</span>:<span class="number">5</span>])  <span class="comment"># 查询数据库</span></span><br></pre></td></tr></table></figure><p>所以，我们可以先对查询集求值，缓存好数据之后再进行上述2和3的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query_res = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"> </span><br><span class="line"><span class="number">123</span> <span class="keyword">in</span> query_res  <span class="comment"># 对查询集求值，会查询数据库并缓存</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(query_res)  <span class="comment"># 命中缓存</span></span><br><span class="line"><span class="built_in">print</span>(query_res[<span class="number">5</span>])  <span class="comment"># 命中缓存</span></span><br><span class="line"><span class="built_in">print</span>(query_res[<span class="number">3</span>:<span class="number">5</span>])  <span class="comment"># 命中缓存</span></span><br></pre></td></tr></table></figure><h3 id="6、exists-与iterator-方法"><a href="#6、exists-与iterator-方法" class="headerlink" title="6、exists()与iterator()方法"></a>6、exists()与iterator()方法</h3><p>简单的使用if语句进行判断也会完全执行整个queryset并且把数据放入cache，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query_res = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">if</span> query_res:  <span class="comment"># 查询数据库并缓存</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(query_res)  <span class="comment"># 命中缓存</span></span><br></pre></td></tr></table></figure><p>若仅仅只需要判断是否存在数据，那么再把所有数据集合都查询回来缓存将会极大地降低效率，此时我们可以使用exists()，只拿回来一条来判断是否存在即可，需要拿所有，当然也不会缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query_res = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">if</span> query_res.exists():  <span class="comment"># 查询数据库，但不缓存</span></span><br><span class="line">    <span class="comment"># SELECT (1) AS `a` FROM `app01_book`  LIMIT 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(query_res)  <span class="comment"># 无法命中任何缓存，需要再次查询数据库</span></span><br></pre></td></tr></table></figure><p>当queryset非常巨大时，cache会成为问题。</p><p>处理成千上万的记录时，将它们一次装入内存是很浪费的。更糟糕的是，巨大的queryset可能会锁住系统 进程，让你的程序濒临崩溃。要避免在遍历数据的同时产生queryset cache，可以使用iterator()方法 来获取数据，iterator并不会产生缓存，处理完数据后就丢弃了，要想重新获取数据得重新拿到iterator()，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">all</span>().iterator()</span><br><span class="line"><span class="comment"># iterator()可以一次只从数据库获取少量数据，这样可以节省内存</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(obj.name)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#强调:再次遍历没有打印,因为迭代器已经在上一次遍历(next)到最后一次了,没得遍历了</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure><p>注意：使用iterator()方法来防止生成cache，意味着遍历同一个queryset时会重复执行查询。所以使用iterator()的时候要当心，确保你的代码在操作一个大的queryset时没有重复执行查询。</p><p><strong><em>\</em>总结:**</strong></p><p>queryset的cache是用于减少程序对数据库的查询，在通常的使用下会保证只有在需要的时候才会查询数据库。 使用exists()和iterator()方法可以优化程序对内存的使用。不过，由于它们并不会生成queryset cache，可能 会造成额外的数据库查询。</p><h2 id="二、跨表查询优化"><a href="#二、跨表查询优化" class="headerlink" title="二、跨表查询优化"></a>二、跨表查询优化</h2><h4 id="select-related"><a href="#select-related" class="headerlink" title="select_related()"></a>select_related()</h4><h4 id="（1）简单使用"><a href="#（1）简单使用" class="headerlink" title="（1）简单使用"></a>（1）简单使用</h4><p>对于一对一字段（OneToOneField）和外键字段（ForeignKey），可以使用select_related 来对QuerySet进行优化，select_related底层就是链表操作</p><p>简单说，在对QuerySet使用select_related()函数后，Django会获取相应外键对应的对象，从而在之后需要的时候不必再查询数据库了，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">res = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.publish.name)  <span class="comment"># 每次执行该行代码都会触发新的sql执行，效率极低</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">底层会先去book表里查出所有的书籍id</span></span><br><span class="line"><span class="string">然后每次for循环都会拿着一个书籍的id去publish表里查到对应出版社的名字</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>    </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 优化</span></span><br><span class="line">res = Book.objects.select_related(<span class="string">&#x27;publish&#x27;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.publish.name)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">底层会先将Book与Publish对应的两张表连接成一张大表，然后一次性将大表的所有数据一次性封装给查询出来的对象</span></span><br><span class="line"><span class="string">    此时对象无论是点击book表的数据还是publish表的数据都无需再走额外的数据库查询了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.publish.city)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第二次for循环直接使用上述缓存即可</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>但需要注意的是：select_related()括号内只能放外键Foreignkey字段</p><p>因为一对多、一对一关系均使用ForeignKey，而多对多则不是，所以select_related不支持多对多关系，若想优化多对多的查询请看下一小节 （2）多外键查询</p><p>如果一个模型中存在多个ForeignKey字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">res = Book.objects.select_related(<span class="string">&quot;publish&quot;</span>)</span><br><span class="line"> </span><br><span class="line">此时我们查询publish相关的时候，不会重复查询，如下</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.publish.name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.publish.city)</span><br><span class="line"> </span><br><span class="line">但如果我们查询的是Book内的其他ForeignKey字段，还是会重新查询</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.other_fk.attr)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 解决方案就是</span></span><br><span class="line">res = Book.objects.select_related(<span class="string">&quot;publish&quot;</span>,<span class="string">&quot;other_fk&quot;</span>)</span><br><span class="line"> </span><br><span class="line">或者使用django1<span class="number">.7</span>之后支持的链式操作</span><br><span class="line">res = Book.objects.select_related(<span class="string">&quot;publish&quot;</span>).select_related(<span class="string">&quot;detail&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="（2）深层查询"><a href="#（2）深层查询" class="headerlink" title="（2）深层查询"></a>（2）深层查询</h4><p>对于跨越了n张表的深层查询， 依然需要查询多次，例如下述代码依然需要重复查询两次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">article=models.Article.objects.select_related(<span class="string">&quot;blog&quot;</span>).get(nid=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(article.blog.user.username)  <span class="comment"># 需要重复两次进行查询</span></span><br></pre></td></tr></table></figure><p>这是因为第一次查询没有query到userInfo表，所以，修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">article=models.Article.objects.select_related(<span class="string">&quot;blog__user&quot;</span>).get(nid=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(article.blog.user.username)</span><br></pre></td></tr></table></figure><h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><p>l select_related主要针一对一和多对一关系进行优化。</p><p>l select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。</p><p>l 可以通过可变长参数指定需要select<em>related的字段名。也可以通过使用双下划线“_</em>”连接字段名来实现指定的递归查询。</p><p>l 没有指定的字段不会缓存，没有指定的深度不会缓存，如果要访问的话Django会再次进行SQL查询。</p><p>l 也可以通过depth参数指定递归的深度，Django会自动缓存指定深度内所有的字段。如果要访问指定深度外的字段，Django会再次进行SQL查询。</p><p>l 也接受无参数的调用，Django会尽可能深的递归查询所有的字段。但注意有Django递归的限制和性能的浪费。</p><p>l Django &gt;= 1.7，链式调用的select_related相当于使用可变长参数。Django &lt; 1.7，链式调用会导致前边的select_related失效，只保留最后一个。</p><h4 id="prefetch-related"><a href="#prefetch-related" class="headerlink" title="prefetch_related()"></a>prefetch_related()</h4><p>对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化，prefetch_related()的底层就是子查询，在使用时select_related与prefetch_related是没有差别的，但是底层是有差别的</p><p>针对一对多字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 效果与select_related()一样</span></span><br><span class="line">res = Book.objects.prefetch_related(<span class="string">&#x27;publish&#x27;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.publish.name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.publish.city)</span><br></pre></td></tr></table></figure><p>针对多对多字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">books = Book.objects.prefetch_related(<span class="string">&#x27;authors&#x27;</span>) <span class="comment"># 底层就是inner join</span></span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="keyword">for</span> author <span class="keyword">in</span> book.authors.<span class="built_in">all</span>():</span><br><span class="line">    <span class="built_in">print</span>(book.name,author.name)</span><br></pre></td></tr></table></figure><p>注意</p><p><em>链表与子查询的效率不一定谁高谁低</em><br><em># 链表有可能遇到很多张表，连在一起，会在耗费很多时间在链表上</em><br><em># 而子查询，每次都一张表，分多步运行，不需要链表，但步骤多了，有可能影响效率</em></p><p><em>通常情况下:</em><br><em>数据量少的话，建议用select_related</em><br><em>数据量比较多，建议用prefetch_related</em></p><p><strong>3 only与defer</strong></p><p>3.1 only</p><p>下例中，因为res是.all()得到的结果集合，所以obj.任意书籍对象自己的属性，均不再走数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">  <span class="built_in">print</span>(obj.name) <span class="comment"># 不走数据库查询</span></span><br><span class="line">  <span class="built_in">print</span>(obj.price) <span class="comment"># 不走数据库查询</span></span><br></pre></td></tr></table></figure><p>因为上面是.all()所以拿到的结果集必然数据量大，如果我们只想要书的名字，可以使用.only()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = Book.objects.only(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.name) </span><br></pre></td></tr></table></figure><p><em># .name不走数据库 .其他字段会重新走数据库查询</em></p><p>3.2 defer</p><p>defer与only刚好相反，除了defer指定的属性外，其他都不需要查数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = Book.objects.defer(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(obj.price) </span><br></pre></td></tr></table></figure><p><em># 除了.name之外，点出的属性都不需要走数据库</em></p><p><em># print(res)</em> <em># 打印res，会触发多条sql的执行来拿到所有的结果集，因为访问了除了name之外的属性</em></p><p><strong>4 整体插入</strong></p><p>创建对象时，尽可能使用bulk_create()来减少SQL查询的数量。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.bulk_create([</span><br><span class="line">Entry(headline=<span class="string">&quot;Python 3.0 Released&quot;</span>),</span><br><span class="line">Entry(headline=<span class="string">&quot;Python 3.1 Planned&quot;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>…更优于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.create(headline=<span class="string">&quot;Python 3.0 Released&quot;</span>)</span><br><span class="line">Entry.objects.create(headline=<span class="string">&quot;Python 3.1 Planned&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意该方法有很多注意事项，所以确保它适用于你的情况。</p><p>这也可以用在ManyToManyFields中，所以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_band.members.add(me, my_friend)</span><br></pre></td></tr></table></figure><p>…更优于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_band.members.add(me)</span><br><span class="line">my_band.members.add(my_friend)</span><br></pre></td></tr></table></figure><p>…其中Bands和Artists具有多对多关联。</p><h1 id="django中ORM的锁"><a href="#django中ORM的锁" class="headerlink" title="django中ORM的锁"></a>django中ORM的锁</h1><h2 id="一、行锁"><a href="#一、行锁" class="headerlink" title="一、行锁"></a>一、行锁</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select_for_update(nowait=<span class="literal">False</span>, skip_locked=<span class="literal">False</span>)</span><br><span class="line">注意必须用在事务里面，至于如何开启事务，我们看下面的事务一节 Book.objects.select_for_update().<span class="built_in">filter</span>(nid=<span class="number">3</span>)  <span class="comment"># 锁住nid=3的行</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数据库锁机制详见</span></span><br><span class="line">https://www.cnblogs.com/linhaifeng/articles/<span class="number">14386584.</span>html</span><br></pre></td></tr></table></figure><p>select_for_update中的两个参数了解即可，因为在MySQL中压根不支持开启它们</p><p>一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。 如果这不想要使查询阻塞 的话，使用select_for_update(nowait=True)。 如果其它事务持有冲突的锁，互斥锁, 那么查询将引发 DatabaseError 异常。你也可以使用select_for_update(skip_locked=True)忽略锁定的行。 nowait和　　skip_locked是互斥的，同时设置会导致ValueError。<em><br>**</em> 目前，postgresql，oracle和mysql数据库后端支持select_for_update()。 但是，MySQL不支持nowait和skip_locked参数。</p><h2 id="二、表锁-了解"><a href="#二、表锁-了解" class="headerlink" title="二、表锁(了解)"></a>二、表锁(了解)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockingManager</span>(models.Manager):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Add lock/unlock functionality to manager.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    Example::</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        class Job(models.Model): #其实不用这么复杂，直接在orm创建表的时候，给这个表定义一个lock和unlock方法，</span></span><br><span class="line"><span class="string">        # 借助django提供的connection模块来发送锁表的原生sql语句和解锁的原生sql语句就可以了，</span></span><br><span class="line"><span class="string">        # 不用外层的这个LckingManager(model.Manager)类</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">            manager = LockingManager()</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">            counter = models.IntegerField(null=True, default=0)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">            @staticmethod</span></span><br><span class="line"><span class="string">            def do_atomic_update(job_id)</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27; Updates job integer, keeping it below 5 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                try:</span></span><br><span class="line"><span class="string">                    # Ensure only one HTTP request can do this update at once.</span></span><br><span class="line"><span class="string">                    Job.objects.lock()</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">                    job = Job.object.get(id=job_id)</span></span><br><span class="line"><span class="string">                    # If we don&#x27;t lock the tables two simultanous</span></span><br><span class="line"><span class="string">                    # requests might both increase the counter</span></span><br><span class="line"><span class="string">                    # going over 5</span></span><br><span class="line"><span class="string">                    if job.counter &lt; 5:</span></span><br><span class="line"><span class="string">                        job.counter += 1                                        </span></span><br><span class="line"><span class="string">                        job.save()</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">                finally:</span></span><br><span class="line"><span class="string">                    Job.objects.unlock()</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; Lock table. </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        Locks the object model table so that atomic update is possible.</span></span><br><span class="line"><span class="string">        Simulatenous database access request pend until the lock is unlock()&#x27;ed.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        Note: If you need to lock multiple tables, you need to do lock them</span></span><br><span class="line"><span class="string">        all in one SQL clause and this function is not enough. To avoid</span></span><br><span class="line"><span class="string">        dead lock, all tables must be locked in the same order.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        See http://dev.mysql.com/doc/refman/5.0/en/lock-tables.html</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        table = self.model._meta.db_table</span><br><span class="line">        logger.debug(<span class="string">&quot;Locking table %s&quot;</span> % table)</span><br><span class="line">        cursor.execute(<span class="string">&quot;LOCK TABLES %s WRITE&quot;</span> % table)</span><br><span class="line">        row = cursor.fetchone()</span><br><span class="line">        <span class="keyword">return</span> row</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unlock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; Unlock the table. &quot;&quot;&quot;</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        table = self.model._meta.db_table</span><br><span class="line">        cursor.execute(<span class="string">&quot;UNLOCK TABLES&quot;</span>)</span><br><span class="line">        row = cursor.fetchone()</span><br><span class="line">        <span class="keyword">return</span> row </span><br></pre></td></tr></table></figure><h1 id="django中ORM开启事务"><a href="#django中ORM开启事务" class="headerlink" title="django中ORM开启事务"></a>django中ORM开启事务</h1><h2 id="一、全局开启"><a href="#一、全局开启" class="headerlink" title="一、全局开启"></a>一、全局开启</h2><p>ATOMIC_REQUESTS设置为True，每个请求过来时，Django会在调用视图方法前开启一个事务。如果请求正确处理并正确返回了结果，Django就会提交该事务，否则，Django会回滚该事务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;mxshop&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;init_command&quot;</span>: <span class="string">&quot;SET default_storage_engine=&#x27;INNODB&#x27;&quot;</span>,</span><br><span class="line">　　　　　　　<span class="comment">#&#x27;init_command&#x27;: &quot;SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;&quot;, #配置开启严格sql模式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;ATOMIC_REQUESTS&quot;</span>: <span class="literal">True</span>, <span class="comment">#全局开启事务，绑定的是http请求响应整个过程</span></span><br><span class="line">        <span class="string">&quot;AUTOCOMMIT&quot;</span>:<span class="literal">False</span>, <span class="comment">#全局取消自动提交，慎用</span></span><br><span class="line">    &#125;，</span><br><span class="line">　　<span class="string">&#x27;other&#x27;</span>:&#123;</span><br><span class="line">　　　　<span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>, </span><br><span class="line">            ......</span><br><span class="line">　　&#125;  <span class="comment"># 还可以配置其他数据</span></span><br></pre></td></tr></table></figure><p>对部分视图函数取消事务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"> </span><br><span class="line"><span class="meta">@transaction.non_atomic_requests</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_view</span>(<span class="params">request</span>):</span><br><span class="line">    do_stuff()</span><br><span class="line"> </span><br><span class="line"><span class="meta">@transaction.non_atomic_requests(<span class="params">using=<span class="string">&#x27;other&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_other_view</span>(<span class="params">request</span>):</span><br><span class="line">    do_stuff_on_the_other_database()</span><br></pre></td></tr></table></figure><p>强调：</p><p>Django官方文档中提到，不推荐开启全局事务。因为每个HTTP 请求都会捆绑一个事务，当流量上来的时候，性能会有影响。</p><h2 id="二、局部开启"><a href="#二、局部开启" class="headerlink" title="二、局部开启"></a>二、局部开启</h2><p>使用transaction.atomic(using=None, savepoint=True)，atomic即原子性，我们就可以用该方法创建一个具备原子性的代码块。一旦代码块正常运行完毕，所有的修改会被提交到数据库。反之，如果有异常，更改会被回滚。</p><p>参数</p><p>using=’other’,’other’对应的是settings.py中配置项DATABASES所指定的某个引擎，意思是当你使用other对应的引擎的时，这个事务才生效。<em></em> savepoint的意思是开启事务保存点。</p><p><strong><em>\</em>用法1：作为上下文管理器来使用**</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> transaction.atomisc():</span><br><span class="line">    <span class="comment"># sql1</span></span><br><span class="line">    <span class="comment"># sql2</span></span><br><span class="line">    <span class="comment"># sql3</span></span><br><span class="line">    <span class="comment"># 在with代码块内写的所有orm操作都是属于同一个事务</span></span><br></pre></td></tr></table></figure><p>上述用法可以写在一个视图函数里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">viewfunc</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># This code executes in autocommit mode (Django&#x27;s default).</span></span><br><span class="line">    do_stuff()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():   <span class="comment">#保存点</span></span><br><span class="line">        <span class="comment"># This code executes inside a transaction.</span></span><br><span class="line">        do_more_stuff()</span><br><span class="line"> </span><br><span class="line">    do_other_stuff()</span><br></pre></td></tr></table></figure><p><strong><em>\</em>用法2：给视图函数装饰器**</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"> </span><br><span class="line"><span class="meta">@transaction.atomic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self,request</span>):</span><br><span class="line">    ...</span><br><span class="line">    sid=transaction.savepoint()  <span class="comment">#开启事务</span></span><br><span class="line">    ...</span><br><span class="line">    transaction.savepoint_rollback(sid)  <span class="comment"># 回滚</span></span><br><span class="line">    ...</span><br><span class="line">    transaction.savepoint_commit(sid)  <span class="comment"># 提交</span></span><br></pre></td></tr></table></figure><p>也可以进行异常处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> IntegrityError, transaction</span><br><span class="line"> </span><br><span class="line"><span class="meta">@transaction.atomic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">viewfunc</span>(<span class="params">request</span>):</span><br><span class="line">    create_parent()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">            generate_relationships()</span><br><span class="line">    <span class="keyword">except</span> IntegrityError:</span><br><span class="line">        handle_exception()</span><br><span class="line"> </span><br><span class="line">    add_children()</span><br></pre></td></tr></table></figure><p><strong><em>\</em>用法3：还可以嵌套使用**</strong></p><p>函数的事务嵌套上下文管理器的事务，上下文管理器的事务嵌套上下文管理器的事务等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> IntegrityError, transaction</span><br><span class="line"> </span><br><span class="line"><span class="meta">@transaction.atomic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">viewfunc</span>(<span class="params">request</span>):</span><br><span class="line">    create_parent()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">            generate_relationships()</span><br><span class="line">　　　　　　　<span class="comment"># other_task()  #还要注意一点，如果你在事务里面写了别的操作，只有这些操作全部完成之后，事务才会commit，也就是说，如果你这个任务是查询上面更改的数据表里面的数据，那么看到的还是事务提交之前的数据。</span></span><br><span class="line">    <span class="keyword">except</span> IntegrityError:</span><br><span class="line">        handle_exception()</span><br><span class="line"> </span><br><span class="line">    add_children()</span><br></pre></td></tr></table></figure><p>上述例子中，即使generate_relationships()中的代码打破了数据完整性约束，你仍然可以在add_children()中执行数据库操作，并且create_parent()产生的更改也有效。需要注意的是，在调用handle_exception()之前，generate_relationships()中的修改就已经被安全的回滚了。因此，如果有需要，你照样可以在异常处理函数中操作数据库。</p><p>强调：尽量不要在atomic代码块中捕获异常，原因如下</p><p>因为当atomic块中的代码执行完的时候，Django会根据代码正常运行来执行相应的提交或者回滚操作。如果在atomic代码块里面捕捉并处理了异常，就有可能隐盖代码本身的错误，从而可能会有一些意料之外的不愉快事情发生。</p><p>担心主要集中在DatabaseError和它的子类（如IntegrityError）。如果这种异常真的发生了，事务就会被破坏掉，而Django会在代码运行完后执行回滚操作。如果你试图在回滚前执行一些数据库操作，Django会抛出TransactionManagementError。通常你会在一个ORM相关的信号处理器抛出异常时遇到这个行为。</p><p>捕获异常的正确方式正如上面atomic代码块所示。如果有必要，添加额外的atomic代码块来做这件事情，也就是事务嵌套。这么做的好处是：当异常发生时，它能明确地告诉你那些操作需要回滚，而那些是不需要的。</p><p>为了保证原子性，atomic还禁止了一些API。像试图提交、回滚事务，以及改变数据库连接的自动提交状态这些操作，在atomic代码块中都是不予许的，否则就会抛出异常。</p><p>下面是Django的事务管理代码：</p><p>• 进入最外层atomic代码块时开启一个事务；</p><p>x• 进入内部atomic代码块时创建保存点；</p><p>• 退出内部atomic时释放或回滚事务；注意如果有嵌套，内层的事务也是不会提交的，可以释放（正常结束）或者回滚</p><p>• 退出最外层atomic代码块时提交或者回滚事务；</p><p>你可以将保存点参数设置成False来禁止内部代码块创建保存点。如果发生了异常，Django在退出第一个父块的时候执行回滚，如果存在保存点，将回滚到这个保存点的位置，否则就是回滚到最外层的代码块。外层事务仍然能够保证原子性。然而，这个选项应该仅仅用于保存点开销较大的时候。毕竟它有个缺点：会破坏上文描述的错误处理机制。</p><p>注意：transaction只对数据库层的操作进行事务管理,不能理解为python操作的事务管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example_view</span>(<span class="params">request</span>):</span><br><span class="line">    tag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        tag = <span class="literal">True</span></span><br><span class="line">        change_obj() <span class="comment"># 修改对象变量</span></span><br><span class="line">        obj.save()</span><br><span class="line">        <span class="keyword">raise</span> DataError</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tag = &quot;</span>,tag) <span class="comment">#结果是True，也就是说在事务中的python变量赋值，即便是事务回滚了，这个赋值也是成功的</span></span><br></pre></td></tr></table></figure><p>还要注意：如果你配置了全局的事务，它和局部事务可能会产生冲突，你可能会发现你局部的事务完成之后，如果你的函数里面其他的sql除了问题，也就是没在这个上下文管理器的局部事务包裹范围内的函数里面的其他的sql出现了问题，你的局部事务也是提交不上的，因为全局会回滚这个请求和响应所涉及到的所有的sql，所以还是建议以后的项目尽量不要配置全局的事务，通过局部事务来搞定，当然了，看你们的业务场景。</p><p>transaction的其他方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@transaction.atomic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">viewfunc</span>(<span class="params">request</span>):</span><br><span class="line"> </span><br><span class="line">  a.save()</span><br><span class="line">  <span class="comment"># open transaction now contains a.save()</span></span><br><span class="line">  sid = transaction.savepoint()  <span class="comment">#创建保存点</span></span><br><span class="line"> </span><br><span class="line">  b.save()</span><br><span class="line">  <span class="comment"># open transaction now contains a.save() and b.save()</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> want_to_keep_b:</span><br><span class="line">      transaction.savepoint_commit(sid) <span class="comment">#提交保存点</span></span><br><span class="line">      <span class="comment"># open transaction still contains a.save() and b.save()</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      transaction.savepoint_rollback(sid)  <span class="comment">#回滚保存点</span></span><br><span class="line">      <span class="comment"># open transaction now contains only a.save()</span></span><br><span class="line"> </span><br><span class="line">  transaction.commit() <span class="comment">#手动提交事务，默认是自动提交的，也就是说如果你没有设置取消自动提交，那么这句话不用写，如果你配置了那个AUTOCOMMIT=False，那么就需要自己手动进行提交。</span></span><br></pre></td></tr></table></figure><p>为保证事务的隔离性，我们还可以结合上面的锁来实现，也就是说在事务里面的查询语句，咱们使用select_for_update显示的加锁方式来保证隔离性，事务结束后才会释放这个锁，例如：（了解）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@transaction.atomic </span><span class="comment">## 轻松开启事务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">## 测试是否存在此用户</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">## 锁定被查询行直到事务结束</span></span><br><span class="line">        user = </span><br><span class="line">    User.objects.select_for_update().get(open_id=self.user.open_id)</span><br><span class="line">        <span class="comment">#other sql 语句</span></span><br><span class="line">    <span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> BaseError(-<span class="number">1</span>, <span class="string">&#x27;User does not exist.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过Django外部的python脚本来测试一下事务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;BMS.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">import</span> datetime</span><br><span class="line">    <span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line">        <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">            new_publisher = models.Publisher.objects.create(name=<span class="string">&quot;火星出版社&quot;</span>)</span><br><span class="line">            models.Book.objects.create(title=<span class="string">&quot;橘子物语&quot;</span>, publish_date=datetime.date.today(), publisher_id=<span class="number">10</span>)  <span class="comment"># 指定一个不存在的出版社id</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://jerrrywang.github.io">JerryWang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://jerrrywang.github.io/2021/11/12/Python/Django/Django%E4%B9%8B%E6%97%85/7.ORM%E4%B9%8B%E5%A4%9A%E8%A1%A8%E5%AE%9E%E4%BE%8B/">https://jerrrywang.github.io/2021/11/12/Python/Django/Django之旅/7.ORM之多表实例/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jerrrywang.github.io" target="_blank">JerryWang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Django/">Django</a></div><div class="post_share"><div class="social-share" data-image="https://jerrrywang.github.io/2018/10/11/photo/ming_9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/18/Python/Django/Django%E4%B9%8B%E6%97%85/8.Ajax/"><img class="prev-cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_7.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ajax</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/12/Python/Django/Django%E4%B9%8B%E6%97%85/6.ORM%E4%B9%8B%E6%A8%A1%E5%9E%8B%E5%B1%82%E8%A1%A8%E6%93%8D%E4%BD%9CFields%E5%AD%97%E6%AE%B5/"><img class="next-cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_0.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ORM之模型层表操作(Fields)字段</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/29/Python/Django/Django-RESTframework/1.%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/" title="接口规范"><img class="cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_0.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-29</div><div class="title">接口规范</div></div></a></div><div><a href="/2021/11/30/Python/Django/Django-RESTframework/2.%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E7%BB%84%E4%BB%B6/" title="请求响应组件"><img class="cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-30</div><div class="title">请求响应组件</div></div></a></div><div><a href="/2021/12/06/Python/Django/Django-RESTframework/3.%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%84%E4%BB%B6/" title="序列化组件"><img class="cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-06</div><div class="title">序列化组件</div></div></a></div><div><a href="/2021/12/08/Python/Django/Django-RESTframework/4.%E8%A7%86%E5%9B%BE%E7%BB%84%E4%BB%B6/" title="视图组件"><img class="cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">视图组件</div></div></a></div><div><a href="/2021/12/10/Python/Django/Django-RESTframework/5.%E4%B8%89%E5%A4%A7%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6/" title="三大认证组件"><img class="cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-10</div><div class="title">三大认证组件</div></div></a></div><div><a href="/2021/12/15/Python/Django/Django-RESTframework/6.jwt%E8%AE%A4%E8%AF%81/" title="jwt认证"><img class="cover" src="https://jerrrywang.github.io/2018/10/11/photo/ming_1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">jwt认证</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC80NTg2Ni8yMjM3Nw"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">JerryWang</div><div class="author-info__description">再牛逼的梦想，也抵不过傻逼一样的坚持！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">150</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">89</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" href="https://jerrrywang.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JerrryWang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wjy_0316@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://weibo.com/allenaq/" target="_blank" title="WeiBo"><i class="fab fa-zhihu"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低级的欲望,放纵即可获得<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高级的欲望,克制才能得到</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">建立关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%85%B3%E7%B3%BB%E4%B9%8B%E5%A4%9A%E5%AF%B9%E4%B8%80-ForeignKey"><span class="toc-number">1.1.</span> <span class="toc-text">表关系之多对一 ForeignKey</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、多对一关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%83%B0%E6%80%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、惰性关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%85%B3%E8%81%94"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、自关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%85%B3%E7%B3%BB%E4%B9%8B%E5%A4%9A%E5%AF%B9%E5%A4%9A-ManyToManyField"><span class="toc-number">1.2.</span> <span class="toc-text">表关系之多对多 ManyToManyField</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、多对多关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%83%B0%E6%80%A7%E5%85%B3%E7%B3%BB%E4%B8%8E%E8%87%AA%E5%85%B3%E8%81%94"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、惰性关系与自关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%E9%A2%9D%E5%A4%96%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%9A%E4%B8%AD%E9%97%B4%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、多对多额外的字段：中间模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%87%AA%E5%85%B3%E8%81%94"><span class="toc-number">1.2.4.</span> <span class="toc-text">4、自关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%85%B3%E7%B3%BB%E4%B9%8B%E4%B8%80%E5%AF%B9%E4%B8%80-OneToOneField"><span class="toc-number">1.3.</span> <span class="toc-text">表关系之一对一 OneToOneField</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、一对一关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%83%B0%E6%80%A7%E5%85%B3%E7%B3%BB-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、惰性关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%85%B3%E8%81%94-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、自关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%85%B6%E4%BB%96-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">4、其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.</span> <span class="toc-text">完整示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">表结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E6%96%87%E4%BB%B6%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">跨文件建立模型关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Meta%E9%80%89%E9%A1%B9"><span class="toc-number">2.</span> <span class="toc-text">Meta选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E5%AE%9E%E4%BE%8B-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">3.</span> <span class="toc-text">多表实例 增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8D%95%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">一、单表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">1、 添加记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、单表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E8%A1%A8delete"><span class="toc-number">3.1.3.</span> <span class="toc-text">3、单表delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8D%95%E8%A1%A8update"><span class="toc-number">3.1.4.</span> <span class="toc-text">4、单表update</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">二、多表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">1、添加记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">2、查询记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%B3%95%E5%88%99%E6%8F%90%E7%82%BC%E5%A6%82%E4%B8%8B"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">1.多表查询的法则提炼如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">2.基于对象的子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E9%93%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">3.基于双下划线的链表查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E8%A1%A5%E5%85%85"><span class="toc-number">3.3.</span> <span class="toc-text">三、查询相关参数补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E5%AF%B9%E5%AF%B9%E5%8F%82%E6%95%B0%EF%BC%9Asymmetrical"><span class="toc-number">3.3.1.</span> <span class="toc-text">1、多对对参数：symmetrical</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81foreign-key%E5%8F%82%E6%95%B0%EF%BC%9Arelated-name%E4%B8%8Erelated-query-name"><span class="toc-number">3.3.2.</span> <span class="toc-text">2、foreign key参数：related_name与related_query_name</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.4.</span> <span class="toc-text">四、\聚合与分组查询**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81annotate"><span class="toc-number">3.4.1.</span> <span class="toc-text">1、annotate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81F%E6%9F%A5%E8%AF%A2%E4%B8%8EQ%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.</span> <span class="toc-text">五、F查询与Q查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-aggregate"><span class="toc-number">3.5.1.</span> <span class="toc-text">1、 aggregate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81F%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">2、F查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Q%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.3.</span> <span class="toc-text">3、Q查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QuerySet%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">QuerySet对象与查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81QuerySet%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">一、QuerySet对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8F%AF%E5%88%87%E7%89%87"><span class="toc-number">4.1.1.</span> <span class="toc-text">1、可切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%AF%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.1.2.</span> <span class="toc-text">2、可迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%83%B0%E6%80%A7%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.1.3.</span> <span class="toc-text">3、惰性查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.4.</span> <span class="toc-text">4、缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BD%95%E6%97%B6%E6%9F%A5%E8%AF%A2%E9%9B%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.5.</span> <span class="toc-text">5、何时查询集不会被缓存?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81exists-%E4%B8%8Eiterator-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.6.</span> <span class="toc-text">6、exists()与iterator()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B7%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">二、跨表查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select-related"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">select_related()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">（1）简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B7%B1%E5%B1%82%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">（2）深层查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.0.4.</span> <span class="toc-text">（3）总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prefetch-related"><span class="toc-number">4.2.0.5.</span> <span class="toc-text">prefetch_related()</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#django%E4%B8%ADORM%E7%9A%84%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">django中ORM的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%A1%8C%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">一、行锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%A1%A8%E9%94%81-%E4%BA%86%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">二、表锁(了解)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#django%E4%B8%ADORM%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">django中ORM开启事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%85%A8%E5%B1%80%E5%BC%80%E5%90%AF"><span class="toc-number">6.1.</span> <span class="toc-text">一、全局开启</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B1%80%E9%83%A8%E5%BC%80%E5%90%AF"><span class="toc-number">6.2.</span> <span class="toc-text">二、局部开启</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%9A%E8%BF%87%20SSH%20%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0%20Shell%20%E8%84%9A%E6%9C%AC/" title="通过 SSH 链接服务器运行本地 Shell 脚本"><img src="https://jerrrywang.github.io/2018/10/11/photo/ming_2.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="通过 SSH 链接服务器运行本地 Shell 脚本"></a><div class="content"><a class="title" href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%9A%E8%BF%87%20SSH%20%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0%20Shell%20%E8%84%9A%E6%9C%AC/" title="通过 SSH 链接服务器运行本地 Shell 脚本">通过 SSH 链接服务器运行本地 Shell 脚本</a><time datetime="2022-11-07T04:35:30.000Z" title="发表于 2022-11-07 12:35:30">2022-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/13/Python/%E6%A8%A1%E5%9D%97/loguru%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" title="loguru日志模块的使用"><img src="https://jerrrywang.github.io/2018/10/11/photo/ming_9.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="loguru日志模块的使用"></a><div class="content"><a class="title" href="/2022/07/13/Python/%E6%A8%A1%E5%9D%97/loguru%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" title="loguru日志模块的使用">loguru日志模块的使用</a><time datetime="2022-07-13T01:10:19.000Z" title="发表于 2022-07-13 09:10:19">2022-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/13/Python/%E6%A8%A1%E5%9D%97/tarfile%E6%A8%A1%E5%9D%97/" title="tarfile压缩模块的使用"><img src="https://jerrrywang.github.io/2018/10/11/photo/ming_1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="tarfile压缩模块的使用"></a><div class="content"><a class="title" href="/2022/07/13/Python/%E6%A8%A1%E5%9D%97/tarfile%E6%A8%A1%E5%9D%97/" title="tarfile压缩模块的使用">tarfile压缩模块的使用</a><time datetime="2022-07-13T01:10:19.000Z" title="发表于 2022-07-13 09:10:19">2022-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/12/Python/%E6%A8%A1%E5%9D%97/python%E7%BB%99%E5%9B%BE%E7%89%87%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0filestools%E6%A8%A1%E5%9D%97/" title="python给图片批量添加水印filestools模块"><img src="https://jerrrywang.github.io/2018/10/11/photo/ming_1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="python给图片批量添加水印filestools模块"></a><div class="content"><a class="title" href="/2022/07/12/Python/%E6%A8%A1%E5%9D%97/python%E7%BB%99%E5%9B%BE%E7%89%87%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0filestools%E6%A8%A1%E5%9D%97/" title="python给图片批量添加水印filestools模块">python给图片批量添加水印filestools模块</a><time datetime="2022-07-12T01:00:19.000Z" title="发表于 2022-07-12 09:00:19">2022-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/18/Python/%E6%A8%A1%E5%9D%97/python%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6filestools%E3%80%81glob%E6%A8%A1%E5%9D%97/" title="python查找文件fnmatch、glob模块"><img src="https://jerrrywang.github.io/2018/10/11/photo/ming_9.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="python查找文件fnmatch、glob模块"></a><div class="content"><a class="title" href="/2022/06/18/Python/%E6%A8%A1%E5%9D%97/python%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6filestools%E3%80%81glob%E6%A8%A1%E5%9D%97/" title="python查找文件fnmatch、glob模块">python查找文件fnmatch、glob模块</a><time datetime="2022-06-18T01:00:19.000Z" title="发表于 2022-06-18 09:00:19">2022-06-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By JerryWang</div><div class="footer_custom_text"><a href="https://jerrrywang.github.io">生活要像水墨画一样的浓厚多姿</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-order="random"></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU,JerryWang,超帥,富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>var font="Ringing"</script><script data-pjax>function electric_clock_injector_config(){var c=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载electric_clock"),c.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://jerrrywang.github.io/api/shubiao/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&(location.pathname,1)&&electric_clock_injector_config()</script><script src="https://jerrrywang.github.io/api/jquery.min.js"></script><script>loc=$.ajax({url:"https://ipapi.co/json/",type:"GET",dataType:"json",async:!1,success:function(e){}}),ip=$.parseJSON(loc.responseText).ip,version=$.parseJSON(loc.responseText).version,city=$.parseJSON(loc.responseText).city,country=$.parseJSON(loc.responseText).country_name</script><script data-pjax src="https://jerrrywang.github.io/api/npm/hexo-electric-clock-plus/clock.js"></script></body></html>